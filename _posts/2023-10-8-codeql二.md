---
layout: post
title: CodeQL从入门到入狱(一)
categories: [blog ]
tags: [CodeQL,]
description: "我~永恒的太阳"
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: cxkjy.github.io


---

# 时隔n天，重蹈覆辙

## 解决Lombok问题

在springboot中用过这个Lombok的类库。

主要功能就是 @Data  和我们写一堆 的getter \setter方法一致

```java
package com.l4yn3.microserviceseclab.data;
import lombok.Data;

@Data
public class Student {
    private int id;
    private String username;
    private int sex;
    private int age;
}
```

但是由于lombok的实现机制，导致Code QL无法获取到Lombok自动生成的代码，所以就导致使用了Lombok的代码即使存在漏洞，也无法识别出来

```java
# get a copy of lombok.jar
wget https://projectlombok.org/downloads/lombok.jar -O "lombok.jar"
# run "delombok" on the source files and write the generated files to a folder named "delombok"
java -jar "lombok.jar" delombok -n --onlyChanged . -d "delombok"
# remove "generated by" comments
find "delombok" -name '*.java' -exec sed '/Generated by delombok/d' -i '{}' ';'
# remove any left-over import statements
find "delombok" -name '*.java' -exec sed '/import lombok/d' -i '{}' ';'
# copy delombok'd files over the original ones
cp -r "delombok/." "./"
# remove the "delombok" folder
rm -rf "delombok"
```

上面的代码，实现的功能是：去掉代码里的lombok注解，并还原setter和getter方法的java代码，从而使CodeQL的Flow流能够顺利走下去，
从而检索到安全漏洞。

其实不太理解这些，如果用到直接套用

```
本来想了想 getter/setter能有什么漏洞，但是又一想，假设路由出的参数直接setname了，然后query查询 getname不就是洞嘛
```

## 持续工程化

因为我们的micro-service-seclab项目，是按照标准生成的微服务结构，那么我们可以使用这个ql规则去跑其他的项目，来自动化检测其它项目，从而做到自动化检测，提高安全检测效率。

`创建数据库`

```java
codeql database create ~/CodeQL/databases/micro-service-seclab  --language="java"  --command="mvn clean install --file pom.xml -Dmaven.test.skip=true" --source-root="~/Code/micro-service-seclab/"
```

通过语句可以执行我们写好的QL文件，然后将结果输出到指定csv文件。

```java
codeql database analyze /CodeQL/databases/micro-service-seclab /CodeQL/ql/java/ql/examples/demo --format=csv --output=/CodeQL/Result/micro-service-seclab.csv --rerun
```

本地测试

```
codeql database analyze /home/jycxk/Desktop/phpstudy/micro_service_seclab/micro_service_seclab_database /home/jycxk/Desktop/CCC/codeql-main/java/ql/examples/snippets/constructor_call.ql --format=csv --output=/home/jycxk/Desktop/JYCCC.csv --rerun
```

真的成功了我丢

![image-20231007211221337](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231007211221337.png)

但是生成的呃呃只有源，后面的数字没看懂啥意思（第一列是source的位置别的母鸡）

![image-20231007211439315](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231007211439315.png)

### `发现了一个贼好用的显示方法`

alerts这个路径就是一个真实的调用链子！！！

![image-20231007211603711](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231007211603711.png)

但是这样大体的漏洞形式就有了，可以细化慢慢分析以后。

## CodeQL进阶

终于来到了进阶了，我配？（bushi）

上面主要完成的就是一个简单的sql注入自动化审计工作

### 用instanceof替代复杂查询语句问题

在上面的污点分析中就用到了，instanceof是用来优化代码结构非常好的语法糖。

![image-20231007212209706](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231007212209706.png)

我们都知道，我们可以使用exists(|)这种子查询的方式定义source和sink，但是如果source/sink特别复杂（比如我们为了规则通用，可能要适配springboot,Thrift RPC, Servlet等source），如果我们把这些都在一个子查询内完成，比如condition 1 or condition 2 or condition 3，这样一直下去，太复杂了。

instanceof给我们提供了一种机制，我们只需要定义一个abstract class，比如这个案例当中的：

```java
/** A data flow source of remote user input. */
abstract class RemoteFlowSource extends DataFlow::Node {
  /** Gets a string that describes the type of this remote flow source. */
  abstract string getSourceType();
}
```

然后





## `疑惑`

```java
在想能不能直接用codeql语法对一个java文件，直接进行查询
```

这里尝试用了

```java
codeql database create --language=java java-database --command="javac StudentService.java"
```

但是在ql查询中会爆出错误（数据库是生成功了，但是查询出错了试了几个基本的也还是不行）

![image-20231007232207098](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231007232207098.png)

`想法又又又来了，试一下能否创建一个maven项目然后创建数据库这种`

