---
layout: post
title: tabby的安装及简单使用
categories: [blog ]
tags: [Java,]
description: ""
image:
  feature: windows.jpg
  credit: JYcxk
  creditlink: azeril.compu
---

```java
这个东西大概我去年就在安装只不过因为种种苦难最后放弃了，现在想想其实当时已经成功了唉。
java这东西真的学一段时间往后一看蛮有趣的
```

`E:\Tabby\tt\tabby-master\build\libs`

```java
这是我tabby的安装位置，然后只需要更换jars文件中的jar包即可
```

![image-20231124195048917](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124195048917.png)

`java -Xmx6g -jar tabby.jar` 运行命令即可,代码运行完运行neo4j查找即可

https://github.com/wh1t3p1g/tabby/blob/master/doc/Tabby%20%E9%A3%9F%E7%94%A8%E6%8C%87%E5%8C%97.md

### 在项目中如何导出jar包（通过构建工件）

本地是idea专业版不可用，需要用社区版

![image-20231124200936587](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124200936587.png)

然后重新构建即可，然后把生成的jar包拖进jars目录即可

![image-20231124200950049](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124200950049.png)

## 命令

:sysinfo,将能看到数据库的存储信息

:schema

```java
match (source:Method {NAME:"execute"})
match (sink:Method {IS_SINK:true, NAME:"getInstance"})<-[:CALL]-(m1:Method)
call apoc.algo.allSimplePaths(m1, source, "<CALL|ALIAS", 20) yield path 
return * limit 20
```

`match()`表示匹配哪些节点，类似SQL中的select。

在 `match (source:Method {NAME:"execute"})`这一句中，`source`是别名，`Method`是节点类型，`{NAME:"execute"}`是匹配的节点内容。这些数据来自于Tabby生成的csv文件。

节点数据一般都是类JSON格式的。在Tabby中有两个重要的节点类型：`Method`和`Class`。

查询`match (source:Method)return *`返回全图类的调用，但会很卡（无用）



查询所有方法名为`excute`的语句:`match(source:Method {NAME:"execute"}) return *`。

![image-20231124202605021](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124202605021.png)

Neo4j图数据库还有一个可查询的数据：关系边，也就是上文模板中`match (sink:Method {IS_SINK:true, NAME:"getInstance"})<-[:CALL]-(m1:Method)`这一句。同样是`match()`方法，只不过后面多了`<-[:CALL]-(m1:Method)`。这个是Neo4j中关系查询的语法。

Neo4j中有三种指向：`() - [] -> ()`、`() <- [] - ()`和`() - [] - ()`。顾名思义，前两种就是看箭头方向表示对应的单项关系；最后一种表示双向关系。

左右两边表示**查询的节点**，在该例中，左边`(sink:Method {IS_SINK:true, NAME:"getInstance"})`就是把方法名为`getInstance`、并且预设规则匹配是SINK的节点查出来；右边`(m1:Method)`表示查询所有的方法；中间表示**关系**。这里的关系是`[:CALL]`调用关系；箭头方向是`() <- [] - ()`，表示节点的指向是从右到左；全部结合起来看就是：**在所有方法中，筛选`getInstance`方法的调用者**。



模板第三句是`call apoc.algo.allSimplePaths(m1, source, "<CALL|ALIAS", 20) yield path`。这是调用了之前给Neo4j安装的插件`apoc`。`apoc.algo.allSimplePaths`语法是：

```
apoc.algo.allSimplePaths(startNode :: NODE?, endNode :: NODE?, relationshipTypesAndDirections :: STRING?, maxNodes :: INTEGER?) :: (path :: PATH?)
```

该函数的主要作用是返回`startNode`到`endNode`之间的关系路径。该函数有四个输入参数：

- `startNode` - 开始节点，也就是Source
- `endNode` - 结束节点，也就是Sink
- `relationshipTypesAndDirections` - Neo4j的关系边，类型是字符串，可以设置为多个关系。查询时会按照这个关系进行路径图的查找
- `maxNodes` - 搜索的最大节点数，也就是路径深度。注意千万不能设太大，尤其是节点很多的时候。

同时还有一个输出参数：

- `path` - 没看到文档有特别说明233，看到[文档](https://neo4j.com/labs/apoc/4.0/algorithms/path-finding-procedures/)中给的都是`YIELD path, weight`。拿就照着[文档](https://neo4j.com/labs/apoc/4.0/algorithms/path-finding-procedures/)来吧

了解完每个语句的功能后，再看回模板可以知道：该模板将方法名为`execute`的节点作为Source；将调用方法名为`getInstance`、且在`/rules/knowledges.json`设置过规则的节点**调用者**设置为Sink；最后调用`allSimplePaths`搜索关系边为`CALL`和`ALIAS`的调用路径，返回20个结果。

```
match (source:Method {NAME:"execute"})
match (sink:Method {IS_SINK:true, NAME:"getInstance"})<-[:CALL]-(m1:Method)
call apoc.algo.allSimplePaths(m1, source, "<CALL|ALIAS", 20) yield path 
return * limit 20
```

但这个查询语句在我们的这个程序里是查不到东西的，因为没有这两个方法的通路。我们可以构造这样的查询语句：查看Tomcat中`doFilter()`到`service()`的通路情况。

```
match (source:Method {NAME:"doFilter"})
match (sink:Method {NAME:"service"})<-[:CALL]-(m1:Method)
call apoc.algo.allSimplePaths(m1, source, "<CALL|ALIAS", 20) yield path 
return * limit 20
```

## 	入门的demo（纯新手入门，可以跳过🤫🤫）

```java
match(source:Method) where source.NAME ="readObject" return source limit 10;
match (source:Method {NAME:"readObject"}) return source limit 10;
```

上面的效果是一样的，但是上面只是单纯的找指定的方法，并没有一个通路

```java
match path=(source:Method)-[:CALL]->(sink:Method)
where source.NAME=~"get.+" and sink.NAME="readObject"
return path
```

看着像是getter调用到readObject的一个通路查找，

```java
match path=(source:Method)-[:CALL]->(sink:Method)
where source.NAME =~ "get.+" and sink.NAME="readObject"
return path
```

发现只有五个节点，简单分析一波	

![image-20231124230042489](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124230042489.png)

好神奇，SealedObject#getObject方法里面就有readObject

![image-20231124230246649](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124230246649.png)

sun.awt.datatransfer#TransferableProxy

![image-20231124230701106](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124230701106.png)

![image-20231124232255539](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124232255539.png)

看了一下左边是右边接口的实现类，[:CALL]怪不得用CALL，因为图中就是这样写的

```java
match (source:Method)-[:CALL|ALIAS*..3]->(sink:Method)
```

如果这个链子不知道有多长，可以用`*..3`这种方式大概限制一下链的最大长度。

再分析一下ALIAS进行一个分析，证实一下上面的想法，证实成功，是接口指向了实现类

![image-20231124232650396](X:\github\cxkjy.github.io\cxkjy.github.io\img\final\image-20231124232650396.png)
